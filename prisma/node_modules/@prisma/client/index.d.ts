
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model UserClassEnrollment
 * 
 */
export type UserClassEnrollment = $Result.DefaultSelection<Prisma.$UserClassEnrollmentPayload>
/**
 * Model Borrow
 * 
 */
export type Borrow = $Result.DefaultSelection<Prisma.$BorrowPayload>
/**
 * Model BorrowGroupMate
 * 
 */
export type BorrowGroupMate = $Result.DefaultSelection<Prisma.$BorrowGroupMatePayload>
/**
 * Model Deficiency
 * 
 */
export type Deficiency = $Result.DefaultSelection<Prisma.$DeficiencyPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  REGULAR: 'REGULAR',
  FACULTY: 'FACULTY',
  STAFF: 'STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  INACTIVE: 'INACTIVE'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const EquipmentCategory: {
  INSTRUMENTS: 'INSTRUMENTS',
  ACCESSORIES: 'ACCESSORIES',
  TOOLS: 'TOOLS',
  CONSUMABLES: 'CONSUMABLES',
  OTHER: 'OTHER'
};

export type EquipmentCategory = (typeof EquipmentCategory)[keyof typeof EquipmentCategory]


export const EquipmentStatus: {
  AVAILABLE: 'AVAILABLE',
  RESERVED: 'RESERVED',
  BORROWED: 'BORROWED',
  UNDER_MAINTENANCE: 'UNDER_MAINTENANCE',
  DEFECTIVE: 'DEFECTIVE',
  OUT_OF_COMMISSION: 'OUT_OF_COMMISSION'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]


export const BorrowStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  ACTIVE: 'ACTIVE',
  PENDING_RETURN: 'PENDING_RETURN',
  RETURNED: 'RETURNED',
  COMPLETED: 'COMPLETED',
  REJECTED_FIC: 'REJECTED_FIC',
  REJECTED_STAFF: 'REJECTED_STAFF',
  CANCELLED: 'CANCELLED',
  OVERDUE: 'OVERDUE'
};

export type BorrowStatus = (typeof BorrowStatus)[keyof typeof BorrowStatus]


export const DeficiencyType: {
  LATE_RETURN: 'LATE_RETURN',
  MISHANDLING: 'MISHANDLING',
  DAMAGE: 'DAMAGE',
  LOSS: 'LOSS',
  OTHER: 'OTHER'
};

export type DeficiencyType = (typeof DeficiencyType)[keyof typeof DeficiencyType]


export const DeficiencyStatus: {
  UNRESOLVED: 'UNRESOLVED',
  RESOLVED: 'RESOLVED',
  UNDER_REVIEW: 'UNDER_REVIEW'
};

export type DeficiencyStatus = (typeof DeficiencyStatus)[keyof typeof DeficiencyStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type EquipmentCategory = $Enums.EquipmentCategory

export const EquipmentCategory: typeof $Enums.EquipmentCategory

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

export type BorrowStatus = $Enums.BorrowStatus

export const BorrowStatus: typeof $Enums.BorrowStatus

export type DeficiencyType = $Enums.DeficiencyType

export const DeficiencyType: typeof $Enums.DeficiencyType

export type DeficiencyStatus = $Enums.DeficiencyStatus

export const DeficiencyStatus: typeof $Enums.DeficiencyStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userClassEnrollment`: Exposes CRUD operations for the **UserClassEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserClassEnrollments
    * const userClassEnrollments = await prisma.userClassEnrollment.findMany()
    * ```
    */
  get userClassEnrollment(): Prisma.UserClassEnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.borrow`: Exposes CRUD operations for the **Borrow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Borrows
    * const borrows = await prisma.borrow.findMany()
    * ```
    */
  get borrow(): Prisma.BorrowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.borrowGroupMate`: Exposes CRUD operations for the **BorrowGroupMate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BorrowGroupMates
    * const borrowGroupMates = await prisma.borrowGroupMate.findMany()
    * ```
    */
  get borrowGroupMate(): Prisma.BorrowGroupMateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deficiency`: Exposes CRUD operations for the **Deficiency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deficiencies
    * const deficiencies = await prisma.deficiency.findMany()
    * ```
    */
  get deficiency(): Prisma.DeficiencyDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Equipment: 'Equipment',
    Class: 'Class',
    UserClassEnrollment: 'UserClassEnrollment',
    Borrow: 'Borrow',
    BorrowGroupMate: 'BorrowGroupMate',
    Deficiency: 'Deficiency'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "equipment" | "class" | "userClassEnrollment" | "borrow" | "borrowGroupMate" | "deficiency"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EquipmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EquipmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ClassFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ClassAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      UserClassEnrollment: {
        payload: Prisma.$UserClassEnrollmentPayload<ExtArgs>
        fields: Prisma.UserClassEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserClassEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserClassEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.UserClassEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserClassEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>
          }
          findMany: {
            args: Prisma.UserClassEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>[]
          }
          create: {
            args: Prisma.UserClassEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>
          }
          createMany: {
            args: Prisma.UserClassEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserClassEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>
          }
          update: {
            args: Prisma.UserClassEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.UserClassEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserClassEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserClassEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserClassEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.UserClassEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserClassEnrollment>
          }
          groupBy: {
            args: Prisma.UserClassEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserClassEnrollmentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserClassEnrollmentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserClassEnrollmentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserClassEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<UserClassEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Borrow: {
        payload: Prisma.$BorrowPayload<ExtArgs>
        fields: Prisma.BorrowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BorrowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BorrowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          findFirst: {
            args: Prisma.BorrowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BorrowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          findMany: {
            args: Prisma.BorrowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>[]
          }
          create: {
            args: Prisma.BorrowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          createMany: {
            args: Prisma.BorrowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BorrowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          update: {
            args: Prisma.BorrowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          deleteMany: {
            args: Prisma.BorrowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BorrowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BorrowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowPayload>
          }
          aggregate: {
            args: Prisma.BorrowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBorrow>
          }
          groupBy: {
            args: Prisma.BorrowGroupByArgs<ExtArgs>
            result: $Utils.Optional<BorrowGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BorrowFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BorrowAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BorrowCountArgs<ExtArgs>
            result: $Utils.Optional<BorrowCountAggregateOutputType> | number
          }
        }
      }
      BorrowGroupMate: {
        payload: Prisma.$BorrowGroupMatePayload<ExtArgs>
        fields: Prisma.BorrowGroupMateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BorrowGroupMateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BorrowGroupMateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>
          }
          findFirst: {
            args: Prisma.BorrowGroupMateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BorrowGroupMateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>
          }
          findMany: {
            args: Prisma.BorrowGroupMateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>[]
          }
          create: {
            args: Prisma.BorrowGroupMateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>
          }
          createMany: {
            args: Prisma.BorrowGroupMateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BorrowGroupMateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>
          }
          update: {
            args: Prisma.BorrowGroupMateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>
          }
          deleteMany: {
            args: Prisma.BorrowGroupMateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BorrowGroupMateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BorrowGroupMateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BorrowGroupMatePayload>
          }
          aggregate: {
            args: Prisma.BorrowGroupMateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBorrowGroupMate>
          }
          groupBy: {
            args: Prisma.BorrowGroupMateGroupByArgs<ExtArgs>
            result: $Utils.Optional<BorrowGroupMateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BorrowGroupMateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BorrowGroupMateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BorrowGroupMateCountArgs<ExtArgs>
            result: $Utils.Optional<BorrowGroupMateCountAggregateOutputType> | number
          }
        }
      }
      Deficiency: {
        payload: Prisma.$DeficiencyPayload<ExtArgs>
        fields: Prisma.DeficiencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeficiencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeficiencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>
          }
          findFirst: {
            args: Prisma.DeficiencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeficiencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>
          }
          findMany: {
            args: Prisma.DeficiencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>[]
          }
          create: {
            args: Prisma.DeficiencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>
          }
          createMany: {
            args: Prisma.DeficiencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeficiencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>
          }
          update: {
            args: Prisma.DeficiencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>
          }
          deleteMany: {
            args: Prisma.DeficiencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeficiencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeficiencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeficiencyPayload>
          }
          aggregate: {
            args: Prisma.DeficiencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeficiency>
          }
          groupBy: {
            args: Prisma.DeficiencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeficiencyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DeficiencyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DeficiencyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DeficiencyCountArgs<ExtArgs>
            result: $Utils.Optional<DeficiencyCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    equipment?: EquipmentOmit
    class?: ClassOmit
    userClassEnrollment?: UserClassEnrollmentOmit
    borrow?: BorrowOmit
    borrowGroupMate?: BorrowGroupMateOmit
    deficiency?: DeficiencyOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    classesTaught: number
    classesEnrolled: number
    borrowsInitiated: number
    borrowsSupervised: number
    ficApprovals: number
    staffApprovals: number
    groupBorrowMembership: number
    userDeficiencies: number
    taggedDeficiencies: number
    notifiedFicDeficiencies: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classesTaught?: boolean | UserCountOutputTypeCountClassesTaughtArgs
    classesEnrolled?: boolean | UserCountOutputTypeCountClassesEnrolledArgs
    borrowsInitiated?: boolean | UserCountOutputTypeCountBorrowsInitiatedArgs
    borrowsSupervised?: boolean | UserCountOutputTypeCountBorrowsSupervisedArgs
    ficApprovals?: boolean | UserCountOutputTypeCountFicApprovalsArgs
    staffApprovals?: boolean | UserCountOutputTypeCountStaffApprovalsArgs
    groupBorrowMembership?: boolean | UserCountOutputTypeCountGroupBorrowMembershipArgs
    userDeficiencies?: boolean | UserCountOutputTypeCountUserDeficienciesArgs
    taggedDeficiencies?: boolean | UserCountOutputTypeCountTaggedDeficienciesArgs
    notifiedFicDeficiencies?: boolean | UserCountOutputTypeCountNotifiedFicDeficienciesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassesTaughtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClassesEnrolledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClassEnrollmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBorrowsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBorrowsSupervisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFicApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGroupBorrowMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowGroupMateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeficiencyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaggedDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeficiencyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotifiedFicDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeficiencyWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    borrowRecords: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrowRecords?: boolean | EquipmentCountOutputTypeCountBorrowRecordsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountBorrowRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    enrollments: number
    borrowRequests: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | ClassCountOutputTypeCountEnrollmentsArgs
    borrowRequests?: boolean | ClassCountOutputTypeCountBorrowRequestsArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClassEnrollmentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountBorrowRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
  }


  /**
   * Count Type BorrowCountOutputType
   */

  export type BorrowCountOutputType = {
    groupMates: number
    deficiencies: number
  }

  export type BorrowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    groupMates?: boolean | BorrowCountOutputTypeCountGroupMatesArgs
    deficiencies?: boolean | BorrowCountOutputTypeCountDeficienciesArgs
  }

  // Custom InputTypes
  /**
   * BorrowCountOutputType without action
   */
  export type BorrowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowCountOutputType
     */
    select?: BorrowCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BorrowCountOutputType without action
   */
  export type BorrowCountOutputTypeCountGroupMatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowGroupMateWhereInput
  }

  /**
   * BorrowCountOutputType without action
   */
  export type BorrowCountOutputTypeCountDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeficiencyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    studentNumber: string | null
    contactNumber: string | null
    sex: string | null
    password: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    studentNumber: string | null
    contactNumber: string | null
    sex: string | null
    password: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    studentNumber: number
    contactNumber: number
    sex: number
    password: number
    role: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    studentNumber?: true
    contactNumber?: true
    sex?: true
    password?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    studentNumber?: true
    contactNumber?: true
    sex?: true
    password?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    studentNumber?: true
    contactNumber?: true
    sex?: true
    password?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    studentNumber: string | null
    contactNumber: string | null
    sex: string | null
    password: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    studentNumber?: boolean
    contactNumber?: boolean
    sex?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    classesTaught?: boolean | User$classesTaughtArgs<ExtArgs>
    classesEnrolled?: boolean | User$classesEnrolledArgs<ExtArgs>
    borrowsInitiated?: boolean | User$borrowsInitiatedArgs<ExtArgs>
    borrowsSupervised?: boolean | User$borrowsSupervisedArgs<ExtArgs>
    ficApprovals?: boolean | User$ficApprovalsArgs<ExtArgs>
    staffApprovals?: boolean | User$staffApprovalsArgs<ExtArgs>
    groupBorrowMembership?: boolean | User$groupBorrowMembershipArgs<ExtArgs>
    userDeficiencies?: boolean | User$userDeficienciesArgs<ExtArgs>
    taggedDeficiencies?: boolean | User$taggedDeficienciesArgs<ExtArgs>
    notifiedFicDeficiencies?: boolean | User$notifiedFicDeficienciesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    studentNumber?: boolean
    contactNumber?: boolean
    sex?: boolean
    password?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "studentNumber" | "contactNumber" | "sex" | "password" | "role" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classesTaught?: boolean | User$classesTaughtArgs<ExtArgs>
    classesEnrolled?: boolean | User$classesEnrolledArgs<ExtArgs>
    borrowsInitiated?: boolean | User$borrowsInitiatedArgs<ExtArgs>
    borrowsSupervised?: boolean | User$borrowsSupervisedArgs<ExtArgs>
    ficApprovals?: boolean | User$ficApprovalsArgs<ExtArgs>
    staffApprovals?: boolean | User$staffApprovalsArgs<ExtArgs>
    groupBorrowMembership?: boolean | User$groupBorrowMembershipArgs<ExtArgs>
    userDeficiencies?: boolean | User$userDeficienciesArgs<ExtArgs>
    taggedDeficiencies?: boolean | User$taggedDeficienciesArgs<ExtArgs>
    notifiedFicDeficiencies?: boolean | User$notifiedFicDeficienciesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      classesTaught: Prisma.$ClassPayload<ExtArgs>[]
      classesEnrolled: Prisma.$UserClassEnrollmentPayload<ExtArgs>[]
      borrowsInitiated: Prisma.$BorrowPayload<ExtArgs>[]
      borrowsSupervised: Prisma.$BorrowPayload<ExtArgs>[]
      ficApprovals: Prisma.$BorrowPayload<ExtArgs>[]
      staffApprovals: Prisma.$BorrowPayload<ExtArgs>[]
      groupBorrowMembership: Prisma.$BorrowGroupMatePayload<ExtArgs>[]
      userDeficiencies: Prisma.$DeficiencyPayload<ExtArgs>[]
      taggedDeficiencies: Prisma.$DeficiencyPayload<ExtArgs>[]
      notifiedFicDeficiencies: Prisma.$DeficiencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      studentNumber: string | null
      contactNumber: string | null
      sex: string | null
      password: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classesTaught<T extends User$classesTaughtArgs<ExtArgs> = {}>(args?: Subset<T, User$classesTaughtArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classesEnrolled<T extends User$classesEnrolledArgs<ExtArgs> = {}>(args?: Subset<T, User$classesEnrolledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    borrowsInitiated<T extends User$borrowsInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, User$borrowsInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    borrowsSupervised<T extends User$borrowsSupervisedArgs<ExtArgs> = {}>(args?: Subset<T, User$borrowsSupervisedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ficApprovals<T extends User$ficApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$ficApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staffApprovals<T extends User$staffApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$staffApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    groupBorrowMembership<T extends User$groupBorrowMembershipArgs<ExtArgs> = {}>(args?: Subset<T, User$groupBorrowMembershipArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userDeficiencies<T extends User$userDeficienciesArgs<ExtArgs> = {}>(args?: Subset<T, User$userDeficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taggedDeficiencies<T extends User$taggedDeficienciesArgs<ExtArgs> = {}>(args?: Subset<T, User$taggedDeficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifiedFicDeficiencies<T extends User$notifiedFicDeficienciesArgs<ExtArgs> = {}>(args?: Subset<T, User$notifiedFicDeficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly studentNumber: FieldRef<"User", 'String'>
    readonly contactNumber: FieldRef<"User", 'String'>
    readonly sex: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.classesTaught
   */
  export type User$classesTaughtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * User.classesEnrolled
   */
  export type User$classesEnrolledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    where?: UserClassEnrollmentWhereInput
    orderBy?: UserClassEnrollmentOrderByWithRelationInput | UserClassEnrollmentOrderByWithRelationInput[]
    cursor?: UserClassEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserClassEnrollmentScalarFieldEnum | UserClassEnrollmentScalarFieldEnum[]
  }

  /**
   * User.borrowsInitiated
   */
  export type User$borrowsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * User.borrowsSupervised
   */
  export type User$borrowsSupervisedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * User.ficApprovals
   */
  export type User$ficApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * User.staffApprovals
   */
  export type User$staffApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * User.groupBorrowMembership
   */
  export type User$groupBorrowMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    where?: BorrowGroupMateWhereInput
    orderBy?: BorrowGroupMateOrderByWithRelationInput | BorrowGroupMateOrderByWithRelationInput[]
    cursor?: BorrowGroupMateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowGroupMateScalarFieldEnum | BorrowGroupMateScalarFieldEnum[]
  }

  /**
   * User.userDeficiencies
   */
  export type User$userDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    where?: DeficiencyWhereInput
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    cursor?: DeficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * User.taggedDeficiencies
   */
  export type User$taggedDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    where?: DeficiencyWhereInput
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    cursor?: DeficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * User.notifiedFicDeficiencies
   */
  export type User$notifiedFicDeficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    where?: DeficiencyWhereInput
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    cursor?: DeficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    stockCount: number | null
    purchaseCost: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    stockCount: number | null
    purchaseCost: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    equipmentId: string | null
    qrCodeValue: string | null
    category: $Enums.EquipmentCategory | null
    condition: string | null
    status: $Enums.EquipmentStatus | null
    stockCount: number | null
    purchaseCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    equipmentId: string | null
    qrCodeValue: string | null
    category: $Enums.EquipmentCategory | null
    condition: string | null
    status: $Enums.EquipmentStatus | null
    stockCount: number | null
    purchaseCost: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    name: number
    equipmentId: number
    qrCodeValue: number
    category: number
    condition: number
    status: number
    stockCount: number
    purchaseCost: number
    images: number
    editHistory: number
    maintenanceLog: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    stockCount?: true
    purchaseCost?: true
  }

  export type EquipmentSumAggregateInputType = {
    stockCount?: true
    purchaseCost?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    name?: true
    equipmentId?: true
    qrCodeValue?: true
    category?: true
    condition?: true
    status?: true
    stockCount?: true
    purchaseCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    name?: true
    equipmentId?: true
    qrCodeValue?: true
    category?: true
    condition?: true
    status?: true
    stockCount?: true
    purchaseCost?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    name?: true
    equipmentId?: true
    qrCodeValue?: true
    category?: true
    condition?: true
    status?: true
    stockCount?: true
    purchaseCost?: true
    images?: true
    editHistory?: true
    maintenanceLog?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    name: string
    equipmentId: string | null
    qrCodeValue: string
    category: $Enums.EquipmentCategory
    condition: string | null
    status: $Enums.EquipmentStatus
    stockCount: number
    purchaseCost: number | null
    images: string[]
    editHistory: JsonValue[]
    maintenanceLog: JsonValue[]
    createdAt: Date
    updatedAt: Date
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    equipmentId?: boolean
    qrCodeValue?: boolean
    category?: boolean
    condition?: boolean
    status?: boolean
    stockCount?: boolean
    purchaseCost?: boolean
    images?: boolean
    editHistory?: boolean
    maintenanceLog?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    borrowRecords?: boolean | Equipment$borrowRecordsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>



  export type EquipmentSelectScalar = {
    id?: boolean
    name?: boolean
    equipmentId?: boolean
    qrCodeValue?: boolean
    category?: boolean
    condition?: boolean
    status?: boolean
    stockCount?: boolean
    purchaseCost?: boolean
    images?: boolean
    editHistory?: boolean
    maintenanceLog?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "equipmentId" | "qrCodeValue" | "category" | "condition" | "status" | "stockCount" | "purchaseCost" | "images" | "editHistory" | "maintenanceLog" | "createdAt" | "updatedAt", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrowRecords?: boolean | Equipment$borrowRecordsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      borrowRecords: Prisma.$BorrowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      equipmentId: string | null
      qrCodeValue: string
      category: $Enums.EquipmentCategory
      condition: string | null
      status: $Enums.EquipmentStatus
      stockCount: number
      purchaseCost: number | null
      images: string[]
      editHistory: Prisma.JsonValue[]
      maintenanceLog: Prisma.JsonValue[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * @param {EquipmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const equipment = await prisma.equipment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EquipmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Equipment.
     * @param {EquipmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const equipment = await prisma.equipment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EquipmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    borrowRecords<T extends Equipment$borrowRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$borrowRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly equipmentId: FieldRef<"Equipment", 'String'>
    readonly qrCodeValue: FieldRef<"Equipment", 'String'>
    readonly category: FieldRef<"Equipment", 'EquipmentCategory'>
    readonly condition: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'EquipmentStatus'>
    readonly stockCount: FieldRef<"Equipment", 'Int'>
    readonly purchaseCost: FieldRef<"Equipment", 'Float'>
    readonly images: FieldRef<"Equipment", 'String[]'>
    readonly editHistory: FieldRef<"Equipment", 'Json[]'>
    readonly maintenanceLog: FieldRef<"Equipment", 'Json[]'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment findRaw
   */
  export type EquipmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Equipment aggregateRaw
   */
  export type EquipmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Equipment.borrowRecords
   */
  export type Equipment$borrowRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    courseCode: string | null
    section: string | null
    semester: string | null
    isActive: boolean | null
    ficId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    courseCode: string | null
    section: string | null
    semester: string | null
    isActive: boolean | null
    ficId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    courseCode: number
    section: number
    semester: number
    isActive: number
    ficId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassMinAggregateInputType = {
    id?: true
    courseCode?: true
    section?: true
    semester?: true
    isActive?: true
    ficId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    courseCode?: true
    section?: true
    semester?: true
    isActive?: true
    ficId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    courseCode?: true
    section?: true
    semester?: true
    isActive?: true
    ficId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    courseCode: string
    section: string
    semester: string
    isActive: boolean
    ficId: string
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseCode?: boolean
    section?: boolean
    semester?: boolean
    isActive?: boolean
    ficId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fic?: boolean | UserDefaultArgs<ExtArgs>
    enrollments?: boolean | Class$enrollmentsArgs<ExtArgs>
    borrowRequests?: boolean | Class$borrowRequestsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>



  export type ClassSelectScalar = {
    id?: boolean
    courseCode?: boolean
    section?: boolean
    semester?: boolean
    isActive?: boolean
    ficId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "courseCode" | "section" | "semester" | "isActive" | "ficId" | "createdAt" | "updatedAt", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fic?: boolean | UserDefaultArgs<ExtArgs>
    enrollments?: boolean | Class$enrollmentsArgs<ExtArgs>
    borrowRequests?: boolean | Class$borrowRequestsArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      fic: Prisma.$UserPayload<ExtArgs>
      enrollments: Prisma.$UserClassEnrollmentPayload<ExtArgs>[]
      borrowRequests: Prisma.$BorrowPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseCode: string
      section: string
      semester: string
      isActive: boolean
      ficId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * @param {ClassFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const class = await prisma.class.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ClassFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Class.
     * @param {ClassAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const class = await prisma.class.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ClassAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fic<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends Class$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    borrowRequests<T extends Class$borrowRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Class$borrowRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly courseCode: FieldRef<"Class", 'String'>
    readonly section: FieldRef<"Class", 'String'>
    readonly semester: FieldRef<"Class", 'String'>
    readonly isActive: FieldRef<"Class", 'Boolean'>
    readonly ficId: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class findRaw
   */
  export type ClassFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Class aggregateRaw
   */
  export type ClassAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Class.enrollments
   */
  export type Class$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    where?: UserClassEnrollmentWhereInput
    orderBy?: UserClassEnrollmentOrderByWithRelationInput | UserClassEnrollmentOrderByWithRelationInput[]
    cursor?: UserClassEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserClassEnrollmentScalarFieldEnum | UserClassEnrollmentScalarFieldEnum[]
  }

  /**
   * Class.borrowRequests
   */
  export type Class$borrowRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    cursor?: BorrowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model UserClassEnrollment
   */

  export type AggregateUserClassEnrollment = {
    _count: UserClassEnrollmentCountAggregateOutputType | null
    _min: UserClassEnrollmentMinAggregateOutputType | null
    _max: UserClassEnrollmentMaxAggregateOutputType | null
  }

  export type UserClassEnrollmentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    createdAt: Date | null
  }

  export type UserClassEnrollmentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    classId: string | null
    createdAt: Date | null
  }

  export type UserClassEnrollmentCountAggregateOutputType = {
    id: number
    userId: number
    classId: number
    createdAt: number
    _all: number
  }


  export type UserClassEnrollmentMinAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    createdAt?: true
  }

  export type UserClassEnrollmentMaxAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    createdAt?: true
  }

  export type UserClassEnrollmentCountAggregateInputType = {
    id?: true
    userId?: true
    classId?: true
    createdAt?: true
    _all?: true
  }

  export type UserClassEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserClassEnrollment to aggregate.
     */
    where?: UserClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassEnrollments to fetch.
     */
    orderBy?: UserClassEnrollmentOrderByWithRelationInput | UserClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserClassEnrollments
    **/
    _count?: true | UserClassEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserClassEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserClassEnrollmentMaxAggregateInputType
  }

  export type GetUserClassEnrollmentAggregateType<T extends UserClassEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserClassEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserClassEnrollment[P]>
      : GetScalarType<T[P], AggregateUserClassEnrollment[P]>
  }




  export type UserClassEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserClassEnrollmentWhereInput
    orderBy?: UserClassEnrollmentOrderByWithAggregationInput | UserClassEnrollmentOrderByWithAggregationInput[]
    by: UserClassEnrollmentScalarFieldEnum[] | UserClassEnrollmentScalarFieldEnum
    having?: UserClassEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserClassEnrollmentCountAggregateInputType | true
    _min?: UserClassEnrollmentMinAggregateInputType
    _max?: UserClassEnrollmentMaxAggregateInputType
  }

  export type UserClassEnrollmentGroupByOutputType = {
    id: string
    userId: string
    classId: string
    createdAt: Date
    _count: UserClassEnrollmentCountAggregateOutputType | null
    _min: UserClassEnrollmentMinAggregateOutputType | null
    _max: UserClassEnrollmentMaxAggregateOutputType | null
  }

  type GetUserClassEnrollmentGroupByPayload<T extends UserClassEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserClassEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserClassEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserClassEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], UserClassEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type UserClassEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    classId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userClassEnrollment"]>



  export type UserClassEnrollmentSelectScalar = {
    id?: boolean
    userId?: boolean
    classId?: boolean
    createdAt?: boolean
  }

  export type UserClassEnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "classId" | "createdAt", ExtArgs["result"]["userClassEnrollment"]>
  export type UserClassEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $UserClassEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserClassEnrollment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      classId: string
      createdAt: Date
    }, ExtArgs["result"]["userClassEnrollment"]>
    composites: {}
  }

  type UserClassEnrollmentGetPayload<S extends boolean | null | undefined | UserClassEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$UserClassEnrollmentPayload, S>

  type UserClassEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserClassEnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserClassEnrollmentCountAggregateInputType | true
    }

  export interface UserClassEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserClassEnrollment'], meta: { name: 'UserClassEnrollment' } }
    /**
     * Find zero or one UserClassEnrollment that matches the filter.
     * @param {UserClassEnrollmentFindUniqueArgs} args - Arguments to find a UserClassEnrollment
     * @example
     * // Get one UserClassEnrollment
     * const userClassEnrollment = await prisma.userClassEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserClassEnrollmentFindUniqueArgs>(args: SelectSubset<T, UserClassEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserClassEnrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserClassEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a UserClassEnrollment
     * @example
     * // Get one UserClassEnrollment
     * const userClassEnrollment = await prisma.userClassEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserClassEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserClassEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserClassEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentFindFirstArgs} args - Arguments to find a UserClassEnrollment
     * @example
     * // Get one UserClassEnrollment
     * const userClassEnrollment = await prisma.userClassEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserClassEnrollmentFindFirstArgs>(args?: SelectSubset<T, UserClassEnrollmentFindFirstArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserClassEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentFindFirstOrThrowArgs} args - Arguments to find a UserClassEnrollment
     * @example
     * // Get one UserClassEnrollment
     * const userClassEnrollment = await prisma.userClassEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserClassEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserClassEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserClassEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserClassEnrollments
     * const userClassEnrollments = await prisma.userClassEnrollment.findMany()
     * 
     * // Get first 10 UserClassEnrollments
     * const userClassEnrollments = await prisma.userClassEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userClassEnrollmentWithIdOnly = await prisma.userClassEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserClassEnrollmentFindManyArgs>(args?: SelectSubset<T, UserClassEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserClassEnrollment.
     * @param {UserClassEnrollmentCreateArgs} args - Arguments to create a UserClassEnrollment.
     * @example
     * // Create one UserClassEnrollment
     * const UserClassEnrollment = await prisma.userClassEnrollment.create({
     *   data: {
     *     // ... data to create a UserClassEnrollment
     *   }
     * })
     * 
     */
    create<T extends UserClassEnrollmentCreateArgs>(args: SelectSubset<T, UserClassEnrollmentCreateArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserClassEnrollments.
     * @param {UserClassEnrollmentCreateManyArgs} args - Arguments to create many UserClassEnrollments.
     * @example
     * // Create many UserClassEnrollments
     * const userClassEnrollment = await prisma.userClassEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserClassEnrollmentCreateManyArgs>(args?: SelectSubset<T, UserClassEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserClassEnrollment.
     * @param {UserClassEnrollmentDeleteArgs} args - Arguments to delete one UserClassEnrollment.
     * @example
     * // Delete one UserClassEnrollment
     * const UserClassEnrollment = await prisma.userClassEnrollment.delete({
     *   where: {
     *     // ... filter to delete one UserClassEnrollment
     *   }
     * })
     * 
     */
    delete<T extends UserClassEnrollmentDeleteArgs>(args: SelectSubset<T, UserClassEnrollmentDeleteArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserClassEnrollment.
     * @param {UserClassEnrollmentUpdateArgs} args - Arguments to update one UserClassEnrollment.
     * @example
     * // Update one UserClassEnrollment
     * const userClassEnrollment = await prisma.userClassEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserClassEnrollmentUpdateArgs>(args: SelectSubset<T, UserClassEnrollmentUpdateArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserClassEnrollments.
     * @param {UserClassEnrollmentDeleteManyArgs} args - Arguments to filter UserClassEnrollments to delete.
     * @example
     * // Delete a few UserClassEnrollments
     * const { count } = await prisma.userClassEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserClassEnrollmentDeleteManyArgs>(args?: SelectSubset<T, UserClassEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserClassEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserClassEnrollments
     * const userClassEnrollment = await prisma.userClassEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserClassEnrollmentUpdateManyArgs>(args: SelectSubset<T, UserClassEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserClassEnrollment.
     * @param {UserClassEnrollmentUpsertArgs} args - Arguments to update or create a UserClassEnrollment.
     * @example
     * // Update or create a UserClassEnrollment
     * const userClassEnrollment = await prisma.userClassEnrollment.upsert({
     *   create: {
     *     // ... data to create a UserClassEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserClassEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends UserClassEnrollmentUpsertArgs>(args: SelectSubset<T, UserClassEnrollmentUpsertArgs<ExtArgs>>): Prisma__UserClassEnrollmentClient<$Result.GetResult<Prisma.$UserClassEnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserClassEnrollments that matches the filter.
     * @param {UserClassEnrollmentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userClassEnrollment = await prisma.userClassEnrollment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserClassEnrollmentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserClassEnrollment.
     * @param {UserClassEnrollmentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userClassEnrollment = await prisma.userClassEnrollment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserClassEnrollmentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserClassEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentCountArgs} args - Arguments to filter UserClassEnrollments to count.
     * @example
     * // Count the number of UserClassEnrollments
     * const count = await prisma.userClassEnrollment.count({
     *   where: {
     *     // ... the filter for the UserClassEnrollments we want to count
     *   }
     * })
    **/
    count<T extends UserClassEnrollmentCountArgs>(
      args?: Subset<T, UserClassEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserClassEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserClassEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserClassEnrollmentAggregateArgs>(args: Subset<T, UserClassEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetUserClassEnrollmentAggregateType<T>>

    /**
     * Group by UserClassEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserClassEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserClassEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserClassEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: UserClassEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserClassEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserClassEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserClassEnrollment model
   */
  readonly fields: UserClassEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserClassEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClassEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserClassEnrollment model
   */
  interface UserClassEnrollmentFieldRefs {
    readonly id: FieldRef<"UserClassEnrollment", 'String'>
    readonly userId: FieldRef<"UserClassEnrollment", 'String'>
    readonly classId: FieldRef<"UserClassEnrollment", 'String'>
    readonly createdAt: FieldRef<"UserClassEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserClassEnrollment findUnique
   */
  export type UserClassEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserClassEnrollment to fetch.
     */
    where: UserClassEnrollmentWhereUniqueInput
  }

  /**
   * UserClassEnrollment findUniqueOrThrow
   */
  export type UserClassEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserClassEnrollment to fetch.
     */
    where: UserClassEnrollmentWhereUniqueInput
  }

  /**
   * UserClassEnrollment findFirst
   */
  export type UserClassEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserClassEnrollment to fetch.
     */
    where?: UserClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassEnrollments to fetch.
     */
    orderBy?: UserClassEnrollmentOrderByWithRelationInput | UserClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClassEnrollments.
     */
    cursor?: UserClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClassEnrollments.
     */
    distinct?: UserClassEnrollmentScalarFieldEnum | UserClassEnrollmentScalarFieldEnum[]
  }

  /**
   * UserClassEnrollment findFirstOrThrow
   */
  export type UserClassEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserClassEnrollment to fetch.
     */
    where?: UserClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassEnrollments to fetch.
     */
    orderBy?: UserClassEnrollmentOrderByWithRelationInput | UserClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserClassEnrollments.
     */
    cursor?: UserClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserClassEnrollments.
     */
    distinct?: UserClassEnrollmentScalarFieldEnum | UserClassEnrollmentScalarFieldEnum[]
  }

  /**
   * UserClassEnrollment findMany
   */
  export type UserClassEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which UserClassEnrollments to fetch.
     */
    where?: UserClassEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserClassEnrollments to fetch.
     */
    orderBy?: UserClassEnrollmentOrderByWithRelationInput | UserClassEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserClassEnrollments.
     */
    cursor?: UserClassEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserClassEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserClassEnrollments.
     */
    skip?: number
    distinct?: UserClassEnrollmentScalarFieldEnum | UserClassEnrollmentScalarFieldEnum[]
  }

  /**
   * UserClassEnrollment create
   */
  export type UserClassEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserClassEnrollment.
     */
    data: XOR<UserClassEnrollmentCreateInput, UserClassEnrollmentUncheckedCreateInput>
  }

  /**
   * UserClassEnrollment createMany
   */
  export type UserClassEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserClassEnrollments.
     */
    data: UserClassEnrollmentCreateManyInput | UserClassEnrollmentCreateManyInput[]
  }

  /**
   * UserClassEnrollment update
   */
  export type UserClassEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserClassEnrollment.
     */
    data: XOR<UserClassEnrollmentUpdateInput, UserClassEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which UserClassEnrollment to update.
     */
    where: UserClassEnrollmentWhereUniqueInput
  }

  /**
   * UserClassEnrollment updateMany
   */
  export type UserClassEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserClassEnrollments.
     */
    data: XOR<UserClassEnrollmentUpdateManyMutationInput, UserClassEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which UserClassEnrollments to update
     */
    where?: UserClassEnrollmentWhereInput
    /**
     * Limit how many UserClassEnrollments to update.
     */
    limit?: number
  }

  /**
   * UserClassEnrollment upsert
   */
  export type UserClassEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserClassEnrollment to update in case it exists.
     */
    where: UserClassEnrollmentWhereUniqueInput
    /**
     * In case the UserClassEnrollment found by the `where` argument doesn't exist, create a new UserClassEnrollment with this data.
     */
    create: XOR<UserClassEnrollmentCreateInput, UserClassEnrollmentUncheckedCreateInput>
    /**
     * In case the UserClassEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserClassEnrollmentUpdateInput, UserClassEnrollmentUncheckedUpdateInput>
  }

  /**
   * UserClassEnrollment delete
   */
  export type UserClassEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which UserClassEnrollment to delete.
     */
    where: UserClassEnrollmentWhereUniqueInput
  }

  /**
   * UserClassEnrollment deleteMany
   */
  export type UserClassEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserClassEnrollments to delete
     */
    where?: UserClassEnrollmentWhereInput
    /**
     * Limit how many UserClassEnrollments to delete.
     */
    limit?: number
  }

  /**
   * UserClassEnrollment findRaw
   */
  export type UserClassEnrollmentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserClassEnrollment aggregateRaw
   */
  export type UserClassEnrollmentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserClassEnrollment without action
   */
  export type UserClassEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserClassEnrollment
     */
    select?: UserClassEnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserClassEnrollment
     */
    omit?: UserClassEnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserClassEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Borrow
   */

  export type AggregateBorrow = {
    _count: BorrowCountAggregateOutputType | null
    _min: BorrowMinAggregateOutputType | null
    _max: BorrowMaxAggregateOutputType | null
  }

  export type BorrowMinAggregateOutputType = {
    id: string | null
    requestSubmissionTime: Date | null
    requestedStartDate: Date | null
    borrowerId: string | null
    classId: string | null
    ficId: string | null
    equipmentId: string | null
    borrowStatus: $Enums.BorrowStatus | null
    approvedByFicId: string | null
    approvedByStaffId: string | null
    checkoutTime: Date | null
    expectedReturnTime: Date | null
    actualReturnTime: Date | null
    returnCondition: string | null
    returnRemarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowMaxAggregateOutputType = {
    id: string | null
    requestSubmissionTime: Date | null
    requestedStartDate: Date | null
    borrowerId: string | null
    classId: string | null
    ficId: string | null
    equipmentId: string | null
    borrowStatus: $Enums.BorrowStatus | null
    approvedByFicId: string | null
    approvedByStaffId: string | null
    checkoutTime: Date | null
    expectedReturnTime: Date | null
    actualReturnTime: Date | null
    returnCondition: string | null
    returnRemarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BorrowCountAggregateOutputType = {
    id: number
    requestSubmissionTime: number
    requestedStartDate: number
    borrowerId: number
    classId: number
    ficId: number
    equipmentId: number
    borrowStatus: number
    approvedByFicId: number
    approvedByStaffId: number
    checkoutTime: number
    expectedReturnTime: number
    actualReturnTime: number
    returnCondition: number
    returnRemarks: number
    editHistory: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BorrowMinAggregateInputType = {
    id?: true
    requestSubmissionTime?: true
    requestedStartDate?: true
    borrowerId?: true
    classId?: true
    ficId?: true
    equipmentId?: true
    borrowStatus?: true
    approvedByFicId?: true
    approvedByStaffId?: true
    checkoutTime?: true
    expectedReturnTime?: true
    actualReturnTime?: true
    returnCondition?: true
    returnRemarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowMaxAggregateInputType = {
    id?: true
    requestSubmissionTime?: true
    requestedStartDate?: true
    borrowerId?: true
    classId?: true
    ficId?: true
    equipmentId?: true
    borrowStatus?: true
    approvedByFicId?: true
    approvedByStaffId?: true
    checkoutTime?: true
    expectedReturnTime?: true
    actualReturnTime?: true
    returnCondition?: true
    returnRemarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BorrowCountAggregateInputType = {
    id?: true
    requestSubmissionTime?: true
    requestedStartDate?: true
    borrowerId?: true
    classId?: true
    ficId?: true
    equipmentId?: true
    borrowStatus?: true
    approvedByFicId?: true
    approvedByStaffId?: true
    checkoutTime?: true
    expectedReturnTime?: true
    actualReturnTime?: true
    returnCondition?: true
    returnRemarks?: true
    editHistory?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BorrowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Borrow to aggregate.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Borrows
    **/
    _count?: true | BorrowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorrowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorrowMaxAggregateInputType
  }

  export type GetBorrowAggregateType<T extends BorrowAggregateArgs> = {
        [P in keyof T & keyof AggregateBorrow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrow[P]>
      : GetScalarType<T[P], AggregateBorrow[P]>
  }




  export type BorrowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowWhereInput
    orderBy?: BorrowOrderByWithAggregationInput | BorrowOrderByWithAggregationInput[]
    by: BorrowScalarFieldEnum[] | BorrowScalarFieldEnum
    having?: BorrowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorrowCountAggregateInputType | true
    _min?: BorrowMinAggregateInputType
    _max?: BorrowMaxAggregateInputType
  }

  export type BorrowGroupByOutputType = {
    id: string
    requestSubmissionTime: Date
    requestedStartDate: Date
    borrowerId: string
    classId: string
    ficId: string | null
    equipmentId: string
    borrowStatus: $Enums.BorrowStatus
    approvedByFicId: string | null
    approvedByStaffId: string | null
    checkoutTime: Date | null
    expectedReturnTime: Date | null
    actualReturnTime: Date | null
    returnCondition: string | null
    returnRemarks: string | null
    editHistory: JsonValue[]
    createdAt: Date
    updatedAt: Date
    _count: BorrowCountAggregateOutputType | null
    _min: BorrowMinAggregateOutputType | null
    _max: BorrowMaxAggregateOutputType | null
  }

  type GetBorrowGroupByPayload<T extends BorrowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BorrowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorrowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowGroupByOutputType[P]>
        }
      >
    >


  export type BorrowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestSubmissionTime?: boolean
    requestedStartDate?: boolean
    borrowerId?: boolean
    classId?: boolean
    ficId?: boolean
    equipmentId?: boolean
    borrowStatus?: boolean
    approvedByFicId?: boolean
    approvedByStaffId?: boolean
    checkoutTime?: boolean
    expectedReturnTime?: boolean
    actualReturnTime?: boolean
    returnCondition?: boolean
    returnRemarks?: boolean
    editHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    borrower?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    fic?: boolean | Borrow$ficArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    groupMates?: boolean | Borrow$groupMatesArgs<ExtArgs>
    approvedByFic?: boolean | Borrow$approvedByFicArgs<ExtArgs>
    approvedByStaff?: boolean | Borrow$approvedByStaffArgs<ExtArgs>
    deficiencies?: boolean | Borrow$deficienciesArgs<ExtArgs>
    _count?: boolean | BorrowCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["borrow"]>



  export type BorrowSelectScalar = {
    id?: boolean
    requestSubmissionTime?: boolean
    requestedStartDate?: boolean
    borrowerId?: boolean
    classId?: boolean
    ficId?: boolean
    equipmentId?: boolean
    borrowStatus?: boolean
    approvedByFicId?: boolean
    approvedByStaffId?: boolean
    checkoutTime?: boolean
    expectedReturnTime?: boolean
    actualReturnTime?: boolean
    returnCondition?: boolean
    returnRemarks?: boolean
    editHistory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BorrowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requestSubmissionTime" | "requestedStartDate" | "borrowerId" | "classId" | "ficId" | "equipmentId" | "borrowStatus" | "approvedByFicId" | "approvedByStaffId" | "checkoutTime" | "expectedReturnTime" | "actualReturnTime" | "returnCondition" | "returnRemarks" | "editHistory" | "createdAt" | "updatedAt", ExtArgs["result"]["borrow"]>
  export type BorrowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrower?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
    fic?: boolean | Borrow$ficArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    groupMates?: boolean | Borrow$groupMatesArgs<ExtArgs>
    approvedByFic?: boolean | Borrow$approvedByFicArgs<ExtArgs>
    approvedByStaff?: boolean | Borrow$approvedByStaffArgs<ExtArgs>
    deficiencies?: boolean | Borrow$deficienciesArgs<ExtArgs>
    _count?: boolean | BorrowCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BorrowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Borrow"
    objects: {
      borrower: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
      fic: Prisma.$UserPayload<ExtArgs> | null
      equipment: Prisma.$EquipmentPayload<ExtArgs>
      groupMates: Prisma.$BorrowGroupMatePayload<ExtArgs>[]
      approvedByFic: Prisma.$UserPayload<ExtArgs> | null
      approvedByStaff: Prisma.$UserPayload<ExtArgs> | null
      deficiencies: Prisma.$DeficiencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requestSubmissionTime: Date
      requestedStartDate: Date
      borrowerId: string
      classId: string
      ficId: string | null
      equipmentId: string
      borrowStatus: $Enums.BorrowStatus
      approvedByFicId: string | null
      approvedByStaffId: string | null
      checkoutTime: Date | null
      expectedReturnTime: Date | null
      actualReturnTime: Date | null
      returnCondition: string | null
      returnRemarks: string | null
      editHistory: Prisma.JsonValue[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["borrow"]>
    composites: {}
  }

  type BorrowGetPayload<S extends boolean | null | undefined | BorrowDefaultArgs> = $Result.GetResult<Prisma.$BorrowPayload, S>

  type BorrowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BorrowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BorrowCountAggregateInputType | true
    }

  export interface BorrowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Borrow'], meta: { name: 'Borrow' } }
    /**
     * Find zero or one Borrow that matches the filter.
     * @param {BorrowFindUniqueArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BorrowFindUniqueArgs>(args: SelectSubset<T, BorrowFindUniqueArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Borrow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BorrowFindUniqueOrThrowArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BorrowFindUniqueOrThrowArgs>(args: SelectSubset<T, BorrowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borrow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowFindFirstArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BorrowFindFirstArgs>(args?: SelectSubset<T, BorrowFindFirstArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Borrow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowFindFirstOrThrowArgs} args - Arguments to find a Borrow
     * @example
     * // Get one Borrow
     * const borrow = await prisma.borrow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BorrowFindFirstOrThrowArgs>(args?: SelectSubset<T, BorrowFindFirstOrThrowArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Borrows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borrows
     * const borrows = await prisma.borrow.findMany()
     * 
     * // Get first 10 Borrows
     * const borrows = await prisma.borrow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borrowWithIdOnly = await prisma.borrow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BorrowFindManyArgs>(args?: SelectSubset<T, BorrowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Borrow.
     * @param {BorrowCreateArgs} args - Arguments to create a Borrow.
     * @example
     * // Create one Borrow
     * const Borrow = await prisma.borrow.create({
     *   data: {
     *     // ... data to create a Borrow
     *   }
     * })
     * 
     */
    create<T extends BorrowCreateArgs>(args: SelectSubset<T, BorrowCreateArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Borrows.
     * @param {BorrowCreateManyArgs} args - Arguments to create many Borrows.
     * @example
     * // Create many Borrows
     * const borrow = await prisma.borrow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BorrowCreateManyArgs>(args?: SelectSubset<T, BorrowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Borrow.
     * @param {BorrowDeleteArgs} args - Arguments to delete one Borrow.
     * @example
     * // Delete one Borrow
     * const Borrow = await prisma.borrow.delete({
     *   where: {
     *     // ... filter to delete one Borrow
     *   }
     * })
     * 
     */
    delete<T extends BorrowDeleteArgs>(args: SelectSubset<T, BorrowDeleteArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Borrow.
     * @param {BorrowUpdateArgs} args - Arguments to update one Borrow.
     * @example
     * // Update one Borrow
     * const borrow = await prisma.borrow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BorrowUpdateArgs>(args: SelectSubset<T, BorrowUpdateArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Borrows.
     * @param {BorrowDeleteManyArgs} args - Arguments to filter Borrows to delete.
     * @example
     * // Delete a few Borrows
     * const { count } = await prisma.borrow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BorrowDeleteManyArgs>(args?: SelectSubset<T, BorrowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borrows
     * const borrow = await prisma.borrow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BorrowUpdateManyArgs>(args: SelectSubset<T, BorrowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Borrow.
     * @param {BorrowUpsertArgs} args - Arguments to update or create a Borrow.
     * @example
     * // Update or create a Borrow
     * const borrow = await prisma.borrow.upsert({
     *   create: {
     *     // ... data to create a Borrow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Borrow we want to update
     *   }
     * })
     */
    upsert<T extends BorrowUpsertArgs>(args: SelectSubset<T, BorrowUpsertArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Borrows that matches the filter.
     * @param {BorrowFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const borrow = await prisma.borrow.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BorrowFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Borrow.
     * @param {BorrowAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const borrow = await prisma.borrow.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BorrowAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Borrows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowCountArgs} args - Arguments to filter Borrows to count.
     * @example
     * // Count the number of Borrows
     * const count = await prisma.borrow.count({
     *   where: {
     *     // ... the filter for the Borrows we want to count
     *   }
     * })
    **/
    count<T extends BorrowCountArgs>(
      args?: Subset<T, BorrowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorrowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Borrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorrowAggregateArgs>(args: Subset<T, BorrowAggregateArgs>): Prisma.PrismaPromise<GetBorrowAggregateType<T>>

    /**
     * Group by Borrow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorrowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorrowGroupByArgs['orderBy'] }
        : { orderBy?: BorrowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorrowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorrowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Borrow model
   */
  readonly fields: BorrowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Borrow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BorrowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    borrower<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fic<T extends Borrow$ficArgs<ExtArgs> = {}>(args?: Subset<T, Borrow$ficArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    groupMates<T extends Borrow$groupMatesArgs<ExtArgs> = {}>(args?: Subset<T, Borrow$groupMatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedByFic<T extends Borrow$approvedByFicArgs<ExtArgs> = {}>(args?: Subset<T, Borrow$approvedByFicArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedByStaff<T extends Borrow$approvedByStaffArgs<ExtArgs> = {}>(args?: Subset<T, Borrow$approvedByStaffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deficiencies<T extends Borrow$deficienciesArgs<ExtArgs> = {}>(args?: Subset<T, Borrow$deficienciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Borrow model
   */
  interface BorrowFieldRefs {
    readonly id: FieldRef<"Borrow", 'String'>
    readonly requestSubmissionTime: FieldRef<"Borrow", 'DateTime'>
    readonly requestedStartDate: FieldRef<"Borrow", 'DateTime'>
    readonly borrowerId: FieldRef<"Borrow", 'String'>
    readonly classId: FieldRef<"Borrow", 'String'>
    readonly ficId: FieldRef<"Borrow", 'String'>
    readonly equipmentId: FieldRef<"Borrow", 'String'>
    readonly borrowStatus: FieldRef<"Borrow", 'BorrowStatus'>
    readonly approvedByFicId: FieldRef<"Borrow", 'String'>
    readonly approvedByStaffId: FieldRef<"Borrow", 'String'>
    readonly checkoutTime: FieldRef<"Borrow", 'DateTime'>
    readonly expectedReturnTime: FieldRef<"Borrow", 'DateTime'>
    readonly actualReturnTime: FieldRef<"Borrow", 'DateTime'>
    readonly returnCondition: FieldRef<"Borrow", 'String'>
    readonly returnRemarks: FieldRef<"Borrow", 'String'>
    readonly editHistory: FieldRef<"Borrow", 'Json[]'>
    readonly createdAt: FieldRef<"Borrow", 'DateTime'>
    readonly updatedAt: FieldRef<"Borrow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Borrow findUnique
   */
  export type BorrowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow findUniqueOrThrow
   */
  export type BorrowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow findFirst
   */
  export type BorrowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Borrows.
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Borrows.
     */
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Borrow findFirstOrThrow
   */
  export type BorrowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrow to fetch.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Borrows.
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Borrows.
     */
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Borrow findMany
   */
  export type BorrowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter, which Borrows to fetch.
     */
    where?: BorrowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Borrows to fetch.
     */
    orderBy?: BorrowOrderByWithRelationInput | BorrowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Borrows.
     */
    cursor?: BorrowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Borrows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Borrows.
     */
    skip?: number
    distinct?: BorrowScalarFieldEnum | BorrowScalarFieldEnum[]
  }

  /**
   * Borrow create
   */
  export type BorrowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * The data needed to create a Borrow.
     */
    data: XOR<BorrowCreateInput, BorrowUncheckedCreateInput>
  }

  /**
   * Borrow createMany
   */
  export type BorrowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Borrows.
     */
    data: BorrowCreateManyInput | BorrowCreateManyInput[]
  }

  /**
   * Borrow update
   */
  export type BorrowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * The data needed to update a Borrow.
     */
    data: XOR<BorrowUpdateInput, BorrowUncheckedUpdateInput>
    /**
     * Choose, which Borrow to update.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow updateMany
   */
  export type BorrowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Borrows.
     */
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyInput>
    /**
     * Filter which Borrows to update
     */
    where?: BorrowWhereInput
    /**
     * Limit how many Borrows to update.
     */
    limit?: number
  }

  /**
   * Borrow upsert
   */
  export type BorrowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * The filter to search for the Borrow to update in case it exists.
     */
    where: BorrowWhereUniqueInput
    /**
     * In case the Borrow found by the `where` argument doesn't exist, create a new Borrow with this data.
     */
    create: XOR<BorrowCreateInput, BorrowUncheckedCreateInput>
    /**
     * In case the Borrow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BorrowUpdateInput, BorrowUncheckedUpdateInput>
  }

  /**
   * Borrow delete
   */
  export type BorrowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
    /**
     * Filter which Borrow to delete.
     */
    where: BorrowWhereUniqueInput
  }

  /**
   * Borrow deleteMany
   */
  export type BorrowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Borrows to delete
     */
    where?: BorrowWhereInput
    /**
     * Limit how many Borrows to delete.
     */
    limit?: number
  }

  /**
   * Borrow findRaw
   */
  export type BorrowFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Borrow aggregateRaw
   */
  export type BorrowAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Borrow.fic
   */
  export type Borrow$ficArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Borrow.groupMates
   */
  export type Borrow$groupMatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    where?: BorrowGroupMateWhereInput
    orderBy?: BorrowGroupMateOrderByWithRelationInput | BorrowGroupMateOrderByWithRelationInput[]
    cursor?: BorrowGroupMateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BorrowGroupMateScalarFieldEnum | BorrowGroupMateScalarFieldEnum[]
  }

  /**
   * Borrow.approvedByFic
   */
  export type Borrow$approvedByFicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Borrow.approvedByStaff
   */
  export type Borrow$approvedByStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Borrow.deficiencies
   */
  export type Borrow$deficienciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    where?: DeficiencyWhereInput
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    cursor?: DeficiencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * Borrow without action
   */
  export type BorrowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Borrow
     */
    select?: BorrowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Borrow
     */
    omit?: BorrowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowInclude<ExtArgs> | null
  }


  /**
   * Model BorrowGroupMate
   */

  export type AggregateBorrowGroupMate = {
    _count: BorrowGroupMateCountAggregateOutputType | null
    _min: BorrowGroupMateMinAggregateOutputType | null
    _max: BorrowGroupMateMaxAggregateOutputType | null
  }

  export type BorrowGroupMateMinAggregateOutputType = {
    id: string | null
    borrowId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type BorrowGroupMateMaxAggregateOutputType = {
    id: string | null
    borrowId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type BorrowGroupMateCountAggregateOutputType = {
    id: number
    borrowId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type BorrowGroupMateMinAggregateInputType = {
    id?: true
    borrowId?: true
    userId?: true
    createdAt?: true
  }

  export type BorrowGroupMateMaxAggregateInputType = {
    id?: true
    borrowId?: true
    userId?: true
    createdAt?: true
  }

  export type BorrowGroupMateCountAggregateInputType = {
    id?: true
    borrowId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type BorrowGroupMateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BorrowGroupMate to aggregate.
     */
    where?: BorrowGroupMateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowGroupMates to fetch.
     */
    orderBy?: BorrowGroupMateOrderByWithRelationInput | BorrowGroupMateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BorrowGroupMateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowGroupMates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowGroupMates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BorrowGroupMates
    **/
    _count?: true | BorrowGroupMateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorrowGroupMateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorrowGroupMateMaxAggregateInputType
  }

  export type GetBorrowGroupMateAggregateType<T extends BorrowGroupMateAggregateArgs> = {
        [P in keyof T & keyof AggregateBorrowGroupMate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBorrowGroupMate[P]>
      : GetScalarType<T[P], AggregateBorrowGroupMate[P]>
  }




  export type BorrowGroupMateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BorrowGroupMateWhereInput
    orderBy?: BorrowGroupMateOrderByWithAggregationInput | BorrowGroupMateOrderByWithAggregationInput[]
    by: BorrowGroupMateScalarFieldEnum[] | BorrowGroupMateScalarFieldEnum
    having?: BorrowGroupMateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorrowGroupMateCountAggregateInputType | true
    _min?: BorrowGroupMateMinAggregateInputType
    _max?: BorrowGroupMateMaxAggregateInputType
  }

  export type BorrowGroupMateGroupByOutputType = {
    id: string
    borrowId: string
    userId: string
    createdAt: Date
    _count: BorrowGroupMateCountAggregateOutputType | null
    _min: BorrowGroupMateMinAggregateOutputType | null
    _max: BorrowGroupMateMaxAggregateOutputType | null
  }

  type GetBorrowGroupMateGroupByPayload<T extends BorrowGroupMateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BorrowGroupMateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorrowGroupMateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorrowGroupMateGroupByOutputType[P]>
            : GetScalarType<T[P], BorrowGroupMateGroupByOutputType[P]>
        }
      >
    >


  export type BorrowGroupMateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borrowId?: boolean
    userId?: boolean
    createdAt?: boolean
    borrow?: boolean | BorrowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["borrowGroupMate"]>



  export type BorrowGroupMateSelectScalar = {
    id?: boolean
    borrowId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type BorrowGroupMateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "borrowId" | "userId" | "createdAt", ExtArgs["result"]["borrowGroupMate"]>
  export type BorrowGroupMateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrow?: boolean | BorrowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BorrowGroupMatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BorrowGroupMate"
    objects: {
      borrow: Prisma.$BorrowPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      borrowId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["borrowGroupMate"]>
    composites: {}
  }

  type BorrowGroupMateGetPayload<S extends boolean | null | undefined | BorrowGroupMateDefaultArgs> = $Result.GetResult<Prisma.$BorrowGroupMatePayload, S>

  type BorrowGroupMateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BorrowGroupMateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BorrowGroupMateCountAggregateInputType | true
    }

  export interface BorrowGroupMateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BorrowGroupMate'], meta: { name: 'BorrowGroupMate' } }
    /**
     * Find zero or one BorrowGroupMate that matches the filter.
     * @param {BorrowGroupMateFindUniqueArgs} args - Arguments to find a BorrowGroupMate
     * @example
     * // Get one BorrowGroupMate
     * const borrowGroupMate = await prisma.borrowGroupMate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BorrowGroupMateFindUniqueArgs>(args: SelectSubset<T, BorrowGroupMateFindUniqueArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BorrowGroupMate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BorrowGroupMateFindUniqueOrThrowArgs} args - Arguments to find a BorrowGroupMate
     * @example
     * // Get one BorrowGroupMate
     * const borrowGroupMate = await prisma.borrowGroupMate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BorrowGroupMateFindUniqueOrThrowArgs>(args: SelectSubset<T, BorrowGroupMateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BorrowGroupMate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateFindFirstArgs} args - Arguments to find a BorrowGroupMate
     * @example
     * // Get one BorrowGroupMate
     * const borrowGroupMate = await prisma.borrowGroupMate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BorrowGroupMateFindFirstArgs>(args?: SelectSubset<T, BorrowGroupMateFindFirstArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BorrowGroupMate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateFindFirstOrThrowArgs} args - Arguments to find a BorrowGroupMate
     * @example
     * // Get one BorrowGroupMate
     * const borrowGroupMate = await prisma.borrowGroupMate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BorrowGroupMateFindFirstOrThrowArgs>(args?: SelectSubset<T, BorrowGroupMateFindFirstOrThrowArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BorrowGroupMates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BorrowGroupMates
     * const borrowGroupMates = await prisma.borrowGroupMate.findMany()
     * 
     * // Get first 10 BorrowGroupMates
     * const borrowGroupMates = await prisma.borrowGroupMate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borrowGroupMateWithIdOnly = await prisma.borrowGroupMate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BorrowGroupMateFindManyArgs>(args?: SelectSubset<T, BorrowGroupMateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BorrowGroupMate.
     * @param {BorrowGroupMateCreateArgs} args - Arguments to create a BorrowGroupMate.
     * @example
     * // Create one BorrowGroupMate
     * const BorrowGroupMate = await prisma.borrowGroupMate.create({
     *   data: {
     *     // ... data to create a BorrowGroupMate
     *   }
     * })
     * 
     */
    create<T extends BorrowGroupMateCreateArgs>(args: SelectSubset<T, BorrowGroupMateCreateArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BorrowGroupMates.
     * @param {BorrowGroupMateCreateManyArgs} args - Arguments to create many BorrowGroupMates.
     * @example
     * // Create many BorrowGroupMates
     * const borrowGroupMate = await prisma.borrowGroupMate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BorrowGroupMateCreateManyArgs>(args?: SelectSubset<T, BorrowGroupMateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BorrowGroupMate.
     * @param {BorrowGroupMateDeleteArgs} args - Arguments to delete one BorrowGroupMate.
     * @example
     * // Delete one BorrowGroupMate
     * const BorrowGroupMate = await prisma.borrowGroupMate.delete({
     *   where: {
     *     // ... filter to delete one BorrowGroupMate
     *   }
     * })
     * 
     */
    delete<T extends BorrowGroupMateDeleteArgs>(args: SelectSubset<T, BorrowGroupMateDeleteArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BorrowGroupMate.
     * @param {BorrowGroupMateUpdateArgs} args - Arguments to update one BorrowGroupMate.
     * @example
     * // Update one BorrowGroupMate
     * const borrowGroupMate = await prisma.borrowGroupMate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BorrowGroupMateUpdateArgs>(args: SelectSubset<T, BorrowGroupMateUpdateArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BorrowGroupMates.
     * @param {BorrowGroupMateDeleteManyArgs} args - Arguments to filter BorrowGroupMates to delete.
     * @example
     * // Delete a few BorrowGroupMates
     * const { count } = await prisma.borrowGroupMate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BorrowGroupMateDeleteManyArgs>(args?: SelectSubset<T, BorrowGroupMateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BorrowGroupMates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BorrowGroupMates
     * const borrowGroupMate = await prisma.borrowGroupMate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BorrowGroupMateUpdateManyArgs>(args: SelectSubset<T, BorrowGroupMateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BorrowGroupMate.
     * @param {BorrowGroupMateUpsertArgs} args - Arguments to update or create a BorrowGroupMate.
     * @example
     * // Update or create a BorrowGroupMate
     * const borrowGroupMate = await prisma.borrowGroupMate.upsert({
     *   create: {
     *     // ... data to create a BorrowGroupMate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BorrowGroupMate we want to update
     *   }
     * })
     */
    upsert<T extends BorrowGroupMateUpsertArgs>(args: SelectSubset<T, BorrowGroupMateUpsertArgs<ExtArgs>>): Prisma__BorrowGroupMateClient<$Result.GetResult<Prisma.$BorrowGroupMatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BorrowGroupMates that matches the filter.
     * @param {BorrowGroupMateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const borrowGroupMate = await prisma.borrowGroupMate.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BorrowGroupMateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BorrowGroupMate.
     * @param {BorrowGroupMateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const borrowGroupMate = await prisma.borrowGroupMate.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BorrowGroupMateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BorrowGroupMates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateCountArgs} args - Arguments to filter BorrowGroupMates to count.
     * @example
     * // Count the number of BorrowGroupMates
     * const count = await prisma.borrowGroupMate.count({
     *   where: {
     *     // ... the filter for the BorrowGroupMates we want to count
     *   }
     * })
    **/
    count<T extends BorrowGroupMateCountArgs>(
      args?: Subset<T, BorrowGroupMateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorrowGroupMateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BorrowGroupMate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorrowGroupMateAggregateArgs>(args: Subset<T, BorrowGroupMateAggregateArgs>): Prisma.PrismaPromise<GetBorrowGroupMateAggregateType<T>>

    /**
     * Group by BorrowGroupMate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorrowGroupMateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorrowGroupMateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorrowGroupMateGroupByArgs['orderBy'] }
        : { orderBy?: BorrowGroupMateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorrowGroupMateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorrowGroupMateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BorrowGroupMate model
   */
  readonly fields: BorrowGroupMateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BorrowGroupMate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BorrowGroupMateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    borrow<T extends BorrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BorrowDefaultArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BorrowGroupMate model
   */
  interface BorrowGroupMateFieldRefs {
    readonly id: FieldRef<"BorrowGroupMate", 'String'>
    readonly borrowId: FieldRef<"BorrowGroupMate", 'String'>
    readonly userId: FieldRef<"BorrowGroupMate", 'String'>
    readonly createdAt: FieldRef<"BorrowGroupMate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BorrowGroupMate findUnique
   */
  export type BorrowGroupMateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * Filter, which BorrowGroupMate to fetch.
     */
    where: BorrowGroupMateWhereUniqueInput
  }

  /**
   * BorrowGroupMate findUniqueOrThrow
   */
  export type BorrowGroupMateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * Filter, which BorrowGroupMate to fetch.
     */
    where: BorrowGroupMateWhereUniqueInput
  }

  /**
   * BorrowGroupMate findFirst
   */
  export type BorrowGroupMateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * Filter, which BorrowGroupMate to fetch.
     */
    where?: BorrowGroupMateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowGroupMates to fetch.
     */
    orderBy?: BorrowGroupMateOrderByWithRelationInput | BorrowGroupMateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BorrowGroupMates.
     */
    cursor?: BorrowGroupMateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowGroupMates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowGroupMates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BorrowGroupMates.
     */
    distinct?: BorrowGroupMateScalarFieldEnum | BorrowGroupMateScalarFieldEnum[]
  }

  /**
   * BorrowGroupMate findFirstOrThrow
   */
  export type BorrowGroupMateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * Filter, which BorrowGroupMate to fetch.
     */
    where?: BorrowGroupMateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowGroupMates to fetch.
     */
    orderBy?: BorrowGroupMateOrderByWithRelationInput | BorrowGroupMateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BorrowGroupMates.
     */
    cursor?: BorrowGroupMateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowGroupMates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowGroupMates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BorrowGroupMates.
     */
    distinct?: BorrowGroupMateScalarFieldEnum | BorrowGroupMateScalarFieldEnum[]
  }

  /**
   * BorrowGroupMate findMany
   */
  export type BorrowGroupMateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * Filter, which BorrowGroupMates to fetch.
     */
    where?: BorrowGroupMateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BorrowGroupMates to fetch.
     */
    orderBy?: BorrowGroupMateOrderByWithRelationInput | BorrowGroupMateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BorrowGroupMates.
     */
    cursor?: BorrowGroupMateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BorrowGroupMates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BorrowGroupMates.
     */
    skip?: number
    distinct?: BorrowGroupMateScalarFieldEnum | BorrowGroupMateScalarFieldEnum[]
  }

  /**
   * BorrowGroupMate create
   */
  export type BorrowGroupMateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * The data needed to create a BorrowGroupMate.
     */
    data: XOR<BorrowGroupMateCreateInput, BorrowGroupMateUncheckedCreateInput>
  }

  /**
   * BorrowGroupMate createMany
   */
  export type BorrowGroupMateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BorrowGroupMates.
     */
    data: BorrowGroupMateCreateManyInput | BorrowGroupMateCreateManyInput[]
  }

  /**
   * BorrowGroupMate update
   */
  export type BorrowGroupMateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * The data needed to update a BorrowGroupMate.
     */
    data: XOR<BorrowGroupMateUpdateInput, BorrowGroupMateUncheckedUpdateInput>
    /**
     * Choose, which BorrowGroupMate to update.
     */
    where: BorrowGroupMateWhereUniqueInput
  }

  /**
   * BorrowGroupMate updateMany
   */
  export type BorrowGroupMateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BorrowGroupMates.
     */
    data: XOR<BorrowGroupMateUpdateManyMutationInput, BorrowGroupMateUncheckedUpdateManyInput>
    /**
     * Filter which BorrowGroupMates to update
     */
    where?: BorrowGroupMateWhereInput
    /**
     * Limit how many BorrowGroupMates to update.
     */
    limit?: number
  }

  /**
   * BorrowGroupMate upsert
   */
  export type BorrowGroupMateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * The filter to search for the BorrowGroupMate to update in case it exists.
     */
    where: BorrowGroupMateWhereUniqueInput
    /**
     * In case the BorrowGroupMate found by the `where` argument doesn't exist, create a new BorrowGroupMate with this data.
     */
    create: XOR<BorrowGroupMateCreateInput, BorrowGroupMateUncheckedCreateInput>
    /**
     * In case the BorrowGroupMate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BorrowGroupMateUpdateInput, BorrowGroupMateUncheckedUpdateInput>
  }

  /**
   * BorrowGroupMate delete
   */
  export type BorrowGroupMateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
    /**
     * Filter which BorrowGroupMate to delete.
     */
    where: BorrowGroupMateWhereUniqueInput
  }

  /**
   * BorrowGroupMate deleteMany
   */
  export type BorrowGroupMateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BorrowGroupMates to delete
     */
    where?: BorrowGroupMateWhereInput
    /**
     * Limit how many BorrowGroupMates to delete.
     */
    limit?: number
  }

  /**
   * BorrowGroupMate findRaw
   */
  export type BorrowGroupMateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BorrowGroupMate aggregateRaw
   */
  export type BorrowGroupMateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BorrowGroupMate without action
   */
  export type BorrowGroupMateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BorrowGroupMate
     */
    select?: BorrowGroupMateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BorrowGroupMate
     */
    omit?: BorrowGroupMateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BorrowGroupMateInclude<ExtArgs> | null
  }


  /**
   * Model Deficiency
   */

  export type AggregateDeficiency = {
    _count: DeficiencyCountAggregateOutputType | null
    _min: DeficiencyMinAggregateOutputType | null
    _max: DeficiencyMaxAggregateOutputType | null
  }

  export type DeficiencyMinAggregateOutputType = {
    id: string | null
    borrowId: string | null
    userId: string | null
    taggedById: string | null
    ficToNotifyId: string | null
    type: $Enums.DeficiencyType | null
    status: $Enums.DeficiencyStatus | null
    description: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeficiencyMaxAggregateOutputType = {
    id: string | null
    borrowId: string | null
    userId: string | null
    taggedById: string | null
    ficToNotifyId: string | null
    type: $Enums.DeficiencyType | null
    status: $Enums.DeficiencyStatus | null
    description: string | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeficiencyCountAggregateOutputType = {
    id: number
    borrowId: number
    userId: number
    taggedById: number
    ficToNotifyId: number
    type: number
    status: number
    description: number
    resolution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeficiencyMinAggregateInputType = {
    id?: true
    borrowId?: true
    userId?: true
    taggedById?: true
    ficToNotifyId?: true
    type?: true
    status?: true
    description?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeficiencyMaxAggregateInputType = {
    id?: true
    borrowId?: true
    userId?: true
    taggedById?: true
    ficToNotifyId?: true
    type?: true
    status?: true
    description?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeficiencyCountAggregateInputType = {
    id?: true
    borrowId?: true
    userId?: true
    taggedById?: true
    ficToNotifyId?: true
    type?: true
    status?: true
    description?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeficiencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deficiency to aggregate.
     */
    where?: DeficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deficiencies to fetch.
     */
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deficiencies
    **/
    _count?: true | DeficiencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeficiencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeficiencyMaxAggregateInputType
  }

  export type GetDeficiencyAggregateType<T extends DeficiencyAggregateArgs> = {
        [P in keyof T & keyof AggregateDeficiency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeficiency[P]>
      : GetScalarType<T[P], AggregateDeficiency[P]>
  }




  export type DeficiencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeficiencyWhereInput
    orderBy?: DeficiencyOrderByWithAggregationInput | DeficiencyOrderByWithAggregationInput[]
    by: DeficiencyScalarFieldEnum[] | DeficiencyScalarFieldEnum
    having?: DeficiencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeficiencyCountAggregateInputType | true
    _min?: DeficiencyMinAggregateInputType
    _max?: DeficiencyMaxAggregateInputType
  }

  export type DeficiencyGroupByOutputType = {
    id: string
    borrowId: string
    userId: string
    taggedById: string
    ficToNotifyId: string | null
    type: $Enums.DeficiencyType
    status: $Enums.DeficiencyStatus
    description: string | null
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeficiencyCountAggregateOutputType | null
    _min: DeficiencyMinAggregateOutputType | null
    _max: DeficiencyMaxAggregateOutputType | null
  }

  type GetDeficiencyGroupByPayload<T extends DeficiencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeficiencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeficiencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeficiencyGroupByOutputType[P]>
            : GetScalarType<T[P], DeficiencyGroupByOutputType[P]>
        }
      >
    >


  export type DeficiencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    borrowId?: boolean
    userId?: boolean
    taggedById?: boolean
    ficToNotifyId?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    borrow?: boolean | BorrowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    taggedBy?: boolean | UserDefaultArgs<ExtArgs>
    ficToNotify?: boolean | Deficiency$ficToNotifyArgs<ExtArgs>
  }, ExtArgs["result"]["deficiency"]>



  export type DeficiencySelectScalar = {
    id?: boolean
    borrowId?: boolean
    userId?: boolean
    taggedById?: boolean
    ficToNotifyId?: boolean
    type?: boolean
    status?: boolean
    description?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeficiencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "borrowId" | "userId" | "taggedById" | "ficToNotifyId" | "type" | "status" | "description" | "resolution" | "createdAt" | "updatedAt", ExtArgs["result"]["deficiency"]>
  export type DeficiencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    borrow?: boolean | BorrowDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    taggedBy?: boolean | UserDefaultArgs<ExtArgs>
    ficToNotify?: boolean | Deficiency$ficToNotifyArgs<ExtArgs>
  }

  export type $DeficiencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deficiency"
    objects: {
      borrow: Prisma.$BorrowPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      taggedBy: Prisma.$UserPayload<ExtArgs>
      ficToNotify: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      borrowId: string
      userId: string
      taggedById: string
      ficToNotifyId: string | null
      type: $Enums.DeficiencyType
      status: $Enums.DeficiencyStatus
      description: string | null
      resolution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deficiency"]>
    composites: {}
  }

  type DeficiencyGetPayload<S extends boolean | null | undefined | DeficiencyDefaultArgs> = $Result.GetResult<Prisma.$DeficiencyPayload, S>

  type DeficiencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeficiencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeficiencyCountAggregateInputType | true
    }

  export interface DeficiencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deficiency'], meta: { name: 'Deficiency' } }
    /**
     * Find zero or one Deficiency that matches the filter.
     * @param {DeficiencyFindUniqueArgs} args - Arguments to find a Deficiency
     * @example
     * // Get one Deficiency
     * const deficiency = await prisma.deficiency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeficiencyFindUniqueArgs>(args: SelectSubset<T, DeficiencyFindUniqueArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deficiency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeficiencyFindUniqueOrThrowArgs} args - Arguments to find a Deficiency
     * @example
     * // Get one Deficiency
     * const deficiency = await prisma.deficiency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeficiencyFindUniqueOrThrowArgs>(args: SelectSubset<T, DeficiencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deficiency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyFindFirstArgs} args - Arguments to find a Deficiency
     * @example
     * // Get one Deficiency
     * const deficiency = await prisma.deficiency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeficiencyFindFirstArgs>(args?: SelectSubset<T, DeficiencyFindFirstArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deficiency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyFindFirstOrThrowArgs} args - Arguments to find a Deficiency
     * @example
     * // Get one Deficiency
     * const deficiency = await prisma.deficiency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeficiencyFindFirstOrThrowArgs>(args?: SelectSubset<T, DeficiencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deficiencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deficiencies
     * const deficiencies = await prisma.deficiency.findMany()
     * 
     * // Get first 10 Deficiencies
     * const deficiencies = await prisma.deficiency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deficiencyWithIdOnly = await prisma.deficiency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeficiencyFindManyArgs>(args?: SelectSubset<T, DeficiencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deficiency.
     * @param {DeficiencyCreateArgs} args - Arguments to create a Deficiency.
     * @example
     * // Create one Deficiency
     * const Deficiency = await prisma.deficiency.create({
     *   data: {
     *     // ... data to create a Deficiency
     *   }
     * })
     * 
     */
    create<T extends DeficiencyCreateArgs>(args: SelectSubset<T, DeficiencyCreateArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deficiencies.
     * @param {DeficiencyCreateManyArgs} args - Arguments to create many Deficiencies.
     * @example
     * // Create many Deficiencies
     * const deficiency = await prisma.deficiency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeficiencyCreateManyArgs>(args?: SelectSubset<T, DeficiencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Deficiency.
     * @param {DeficiencyDeleteArgs} args - Arguments to delete one Deficiency.
     * @example
     * // Delete one Deficiency
     * const Deficiency = await prisma.deficiency.delete({
     *   where: {
     *     // ... filter to delete one Deficiency
     *   }
     * })
     * 
     */
    delete<T extends DeficiencyDeleteArgs>(args: SelectSubset<T, DeficiencyDeleteArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deficiency.
     * @param {DeficiencyUpdateArgs} args - Arguments to update one Deficiency.
     * @example
     * // Update one Deficiency
     * const deficiency = await prisma.deficiency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeficiencyUpdateArgs>(args: SelectSubset<T, DeficiencyUpdateArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deficiencies.
     * @param {DeficiencyDeleteManyArgs} args - Arguments to filter Deficiencies to delete.
     * @example
     * // Delete a few Deficiencies
     * const { count } = await prisma.deficiency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeficiencyDeleteManyArgs>(args?: SelectSubset<T, DeficiencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deficiencies
     * const deficiency = await prisma.deficiency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeficiencyUpdateManyArgs>(args: SelectSubset<T, DeficiencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Deficiency.
     * @param {DeficiencyUpsertArgs} args - Arguments to update or create a Deficiency.
     * @example
     * // Update or create a Deficiency
     * const deficiency = await prisma.deficiency.upsert({
     *   create: {
     *     // ... data to create a Deficiency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deficiency we want to update
     *   }
     * })
     */
    upsert<T extends DeficiencyUpsertArgs>(args: SelectSubset<T, DeficiencyUpsertArgs<ExtArgs>>): Prisma__DeficiencyClient<$Result.GetResult<Prisma.$DeficiencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deficiencies that matches the filter.
     * @param {DeficiencyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const deficiency = await prisma.deficiency.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DeficiencyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Deficiency.
     * @param {DeficiencyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const deficiency = await prisma.deficiency.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DeficiencyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Deficiencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyCountArgs} args - Arguments to filter Deficiencies to count.
     * @example
     * // Count the number of Deficiencies
     * const count = await prisma.deficiency.count({
     *   where: {
     *     // ... the filter for the Deficiencies we want to count
     *   }
     * })
    **/
    count<T extends DeficiencyCountArgs>(
      args?: Subset<T, DeficiencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeficiencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeficiencyAggregateArgs>(args: Subset<T, DeficiencyAggregateArgs>): Prisma.PrismaPromise<GetDeficiencyAggregateType<T>>

    /**
     * Group by Deficiency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeficiencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeficiencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeficiencyGroupByArgs['orderBy'] }
        : { orderBy?: DeficiencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeficiencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeficiencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deficiency model
   */
  readonly fields: DeficiencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deficiency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeficiencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    borrow<T extends BorrowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BorrowDefaultArgs<ExtArgs>>): Prisma__BorrowClient<$Result.GetResult<Prisma.$BorrowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taggedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ficToNotify<T extends Deficiency$ficToNotifyArgs<ExtArgs> = {}>(args?: Subset<T, Deficiency$ficToNotifyArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deficiency model
   */
  interface DeficiencyFieldRefs {
    readonly id: FieldRef<"Deficiency", 'String'>
    readonly borrowId: FieldRef<"Deficiency", 'String'>
    readonly userId: FieldRef<"Deficiency", 'String'>
    readonly taggedById: FieldRef<"Deficiency", 'String'>
    readonly ficToNotifyId: FieldRef<"Deficiency", 'String'>
    readonly type: FieldRef<"Deficiency", 'DeficiencyType'>
    readonly status: FieldRef<"Deficiency", 'DeficiencyStatus'>
    readonly description: FieldRef<"Deficiency", 'String'>
    readonly resolution: FieldRef<"Deficiency", 'String'>
    readonly createdAt: FieldRef<"Deficiency", 'DateTime'>
    readonly updatedAt: FieldRef<"Deficiency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deficiency findUnique
   */
  export type DeficiencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Deficiency to fetch.
     */
    where: DeficiencyWhereUniqueInput
  }

  /**
   * Deficiency findUniqueOrThrow
   */
  export type DeficiencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Deficiency to fetch.
     */
    where: DeficiencyWhereUniqueInput
  }

  /**
   * Deficiency findFirst
   */
  export type DeficiencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Deficiency to fetch.
     */
    where?: DeficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deficiencies to fetch.
     */
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deficiencies.
     */
    cursor?: DeficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deficiencies.
     */
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * Deficiency findFirstOrThrow
   */
  export type DeficiencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Deficiency to fetch.
     */
    where?: DeficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deficiencies to fetch.
     */
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deficiencies.
     */
    cursor?: DeficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deficiencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deficiencies.
     */
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * Deficiency findMany
   */
  export type DeficiencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * Filter, which Deficiencies to fetch.
     */
    where?: DeficiencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deficiencies to fetch.
     */
    orderBy?: DeficiencyOrderByWithRelationInput | DeficiencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deficiencies.
     */
    cursor?: DeficiencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deficiencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deficiencies.
     */
    skip?: number
    distinct?: DeficiencyScalarFieldEnum | DeficiencyScalarFieldEnum[]
  }

  /**
   * Deficiency create
   */
  export type DeficiencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Deficiency.
     */
    data: XOR<DeficiencyCreateInput, DeficiencyUncheckedCreateInput>
  }

  /**
   * Deficiency createMany
   */
  export type DeficiencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deficiencies.
     */
    data: DeficiencyCreateManyInput | DeficiencyCreateManyInput[]
  }

  /**
   * Deficiency update
   */
  export type DeficiencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Deficiency.
     */
    data: XOR<DeficiencyUpdateInput, DeficiencyUncheckedUpdateInput>
    /**
     * Choose, which Deficiency to update.
     */
    where: DeficiencyWhereUniqueInput
  }

  /**
   * Deficiency updateMany
   */
  export type DeficiencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deficiencies.
     */
    data: XOR<DeficiencyUpdateManyMutationInput, DeficiencyUncheckedUpdateManyInput>
    /**
     * Filter which Deficiencies to update
     */
    where?: DeficiencyWhereInput
    /**
     * Limit how many Deficiencies to update.
     */
    limit?: number
  }

  /**
   * Deficiency upsert
   */
  export type DeficiencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Deficiency to update in case it exists.
     */
    where: DeficiencyWhereUniqueInput
    /**
     * In case the Deficiency found by the `where` argument doesn't exist, create a new Deficiency with this data.
     */
    create: XOR<DeficiencyCreateInput, DeficiencyUncheckedCreateInput>
    /**
     * In case the Deficiency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeficiencyUpdateInput, DeficiencyUncheckedUpdateInput>
  }

  /**
   * Deficiency delete
   */
  export type DeficiencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
    /**
     * Filter which Deficiency to delete.
     */
    where: DeficiencyWhereUniqueInput
  }

  /**
   * Deficiency deleteMany
   */
  export type DeficiencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deficiencies to delete
     */
    where?: DeficiencyWhereInput
    /**
     * Limit how many Deficiencies to delete.
     */
    limit?: number
  }

  /**
   * Deficiency findRaw
   */
  export type DeficiencyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Deficiency aggregateRaw
   */
  export type DeficiencyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Deficiency.ficToNotify
   */
  export type Deficiency$ficToNotifyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Deficiency without action
   */
  export type DeficiencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deficiency
     */
    select?: DeficiencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deficiency
     */
    omit?: DeficiencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeficiencyInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    studentNumber: 'studentNumber',
    contactNumber: 'contactNumber',
    sex: 'sex',
    password: 'password',
    role: 'role',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    equipmentId: 'equipmentId',
    qrCodeValue: 'qrCodeValue',
    category: 'category',
    condition: 'condition',
    status: 'status',
    stockCount: 'stockCount',
    purchaseCost: 'purchaseCost',
    images: 'images',
    editHistory: 'editHistory',
    maintenanceLog: 'maintenanceLog',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    courseCode: 'courseCode',
    section: 'section',
    semester: 'semester',
    isActive: 'isActive',
    ficId: 'ficId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const UserClassEnrollmentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    classId: 'classId',
    createdAt: 'createdAt'
  };

  export type UserClassEnrollmentScalarFieldEnum = (typeof UserClassEnrollmentScalarFieldEnum)[keyof typeof UserClassEnrollmentScalarFieldEnum]


  export const BorrowScalarFieldEnum: {
    id: 'id',
    requestSubmissionTime: 'requestSubmissionTime',
    requestedStartDate: 'requestedStartDate',
    borrowerId: 'borrowerId',
    classId: 'classId',
    ficId: 'ficId',
    equipmentId: 'equipmentId',
    borrowStatus: 'borrowStatus',
    approvedByFicId: 'approvedByFicId',
    approvedByStaffId: 'approvedByStaffId',
    checkoutTime: 'checkoutTime',
    expectedReturnTime: 'expectedReturnTime',
    actualReturnTime: 'actualReturnTime',
    returnCondition: 'returnCondition',
    returnRemarks: 'returnRemarks',
    editHistory: 'editHistory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BorrowScalarFieldEnum = (typeof BorrowScalarFieldEnum)[keyof typeof BorrowScalarFieldEnum]


  export const BorrowGroupMateScalarFieldEnum: {
    id: 'id',
    borrowId: 'borrowId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type BorrowGroupMateScalarFieldEnum = (typeof BorrowGroupMateScalarFieldEnum)[keyof typeof BorrowGroupMateScalarFieldEnum]


  export const DeficiencyScalarFieldEnum: {
    id: 'id',
    borrowId: 'borrowId',
    userId: 'userId',
    taggedById: 'taggedById',
    ficToNotifyId: 'ficToNotifyId',
    type: 'type',
    status: 'status',
    description: 'description',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeficiencyScalarFieldEnum = (typeof DeficiencyScalarFieldEnum)[keyof typeof DeficiencyScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'EquipmentCategory'
   */
  export type EnumEquipmentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentCategory'>
    


  /**
   * Reference to a field of type 'EquipmentCategory[]'
   */
  export type ListEnumEquipmentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentCategory[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json[]'
   */
  export type ListJsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BorrowStatus'
   */
  export type EnumBorrowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BorrowStatus'>
    


  /**
   * Reference to a field of type 'BorrowStatus[]'
   */
  export type ListEnumBorrowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BorrowStatus[]'>
    


  /**
   * Reference to a field of type 'DeficiencyType'
   */
  export type EnumDeficiencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeficiencyType'>
    


  /**
   * Reference to a field of type 'DeficiencyType[]'
   */
  export type ListEnumDeficiencyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeficiencyType[]'>
    


  /**
   * Reference to a field of type 'DeficiencyStatus'
   */
  export type EnumDeficiencyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeficiencyStatus'>
    


  /**
   * Reference to a field of type 'DeficiencyStatus[]'
   */
  export type ListEnumDeficiencyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeficiencyStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    studentNumber?: StringNullableFilter<"User"> | string | null
    contactNumber?: StringNullableFilter<"User"> | string | null
    sex?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    classesTaught?: ClassListRelationFilter
    classesEnrolled?: UserClassEnrollmentListRelationFilter
    borrowsInitiated?: BorrowListRelationFilter
    borrowsSupervised?: BorrowListRelationFilter
    ficApprovals?: BorrowListRelationFilter
    staffApprovals?: BorrowListRelationFilter
    groupBorrowMembership?: BorrowGroupMateListRelationFilter
    userDeficiencies?: DeficiencyListRelationFilter
    taggedDeficiencies?: DeficiencyListRelationFilter
    notifiedFicDeficiencies?: DeficiencyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    studentNumber?: SortOrder
    contactNumber?: SortOrder
    sex?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    classesTaught?: ClassOrderByRelationAggregateInput
    classesEnrolled?: UserClassEnrollmentOrderByRelationAggregateInput
    borrowsInitiated?: BorrowOrderByRelationAggregateInput
    borrowsSupervised?: BorrowOrderByRelationAggregateInput
    ficApprovals?: BorrowOrderByRelationAggregateInput
    staffApprovals?: BorrowOrderByRelationAggregateInput
    groupBorrowMembership?: BorrowGroupMateOrderByRelationAggregateInput
    userDeficiencies?: DeficiencyOrderByRelationAggregateInput
    taggedDeficiencies?: DeficiencyOrderByRelationAggregateInput
    notifiedFicDeficiencies?: DeficiencyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    studentNumber?: StringNullableFilter<"User"> | string | null
    contactNumber?: StringNullableFilter<"User"> | string | null
    sex?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    classesTaught?: ClassListRelationFilter
    classesEnrolled?: UserClassEnrollmentListRelationFilter
    borrowsInitiated?: BorrowListRelationFilter
    borrowsSupervised?: BorrowListRelationFilter
    ficApprovals?: BorrowListRelationFilter
    staffApprovals?: BorrowListRelationFilter
    groupBorrowMembership?: BorrowGroupMateListRelationFilter
    userDeficiencies?: DeficiencyListRelationFilter
    taggedDeficiencies?: DeficiencyListRelationFilter
    notifiedFicDeficiencies?: DeficiencyListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    studentNumber?: SortOrder
    contactNumber?: SortOrder
    sex?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    studentNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    sex?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    equipmentId?: StringNullableFilter<"Equipment"> | string | null
    qrCodeValue?: StringFilter<"Equipment"> | string
    category?: EnumEquipmentCategoryFilter<"Equipment"> | $Enums.EquipmentCategory
    condition?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    stockCount?: IntFilter<"Equipment"> | number
    purchaseCost?: FloatNullableFilter<"Equipment"> | number | null
    images?: StringNullableListFilter<"Equipment">
    editHistory?: JsonNullableListFilter<"Equipment">
    maintenanceLog?: JsonNullableListFilter<"Equipment">
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    borrowRecords?: BorrowListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    equipmentId?: SortOrder
    qrCodeValue?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    stockCount?: SortOrder
    purchaseCost?: SortOrder
    images?: SortOrder
    editHistory?: SortOrder
    maintenanceLog?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrowRecords?: BorrowOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    equipmentId?: string
    qrCodeValue?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    name?: StringFilter<"Equipment"> | string
    category?: EnumEquipmentCategoryFilter<"Equipment"> | $Enums.EquipmentCategory
    condition?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    stockCount?: IntFilter<"Equipment"> | number
    purchaseCost?: FloatNullableFilter<"Equipment"> | number | null
    images?: StringNullableListFilter<"Equipment">
    editHistory?: JsonNullableListFilter<"Equipment">
    maintenanceLog?: JsonNullableListFilter<"Equipment">
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    borrowRecords?: BorrowListRelationFilter
  }, "id" | "equipmentId" | "qrCodeValue">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    equipmentId?: SortOrder
    qrCodeValue?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    stockCount?: SortOrder
    purchaseCost?: SortOrder
    images?: SortOrder
    editHistory?: SortOrder
    maintenanceLog?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    equipmentId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    qrCodeValue?: StringWithAggregatesFilter<"Equipment"> | string
    category?: EnumEquipmentCategoryWithAggregatesFilter<"Equipment"> | $Enums.EquipmentCategory
    condition?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusWithAggregatesFilter<"Equipment"> | $Enums.EquipmentStatus
    stockCount?: IntWithAggregatesFilter<"Equipment"> | number
    purchaseCost?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    images?: StringNullableListFilter<"Equipment">
    editHistory?: JsonNullableListFilter<"Equipment">
    maintenanceLog?: JsonNullableListFilter<"Equipment">
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    courseCode?: StringFilter<"Class"> | string
    section?: StringFilter<"Class"> | string
    semester?: StringFilter<"Class"> | string
    isActive?: BoolFilter<"Class"> | boolean
    ficId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    fic?: XOR<UserScalarRelationFilter, UserWhereInput>
    enrollments?: UserClassEnrollmentListRelationFilter
    borrowRequests?: BorrowListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    courseCode?: SortOrder
    section?: SortOrder
    semester?: SortOrder
    isActive?: SortOrder
    ficId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fic?: UserOrderByWithRelationInput
    enrollments?: UserClassEnrollmentOrderByRelationAggregateInput
    borrowRequests?: BorrowOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    courseCode_section_semester?: ClassCourseCodeSectionSemesterCompoundUniqueInput
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    courseCode?: StringFilter<"Class"> | string
    section?: StringFilter<"Class"> | string
    semester?: StringFilter<"Class"> | string
    isActive?: BoolFilter<"Class"> | boolean
    ficId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    fic?: XOR<UserScalarRelationFilter, UserWhereInput>
    enrollments?: UserClassEnrollmentListRelationFilter
    borrowRequests?: BorrowListRelationFilter
  }, "id" | "courseCode_section_semester">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    courseCode?: SortOrder
    section?: SortOrder
    semester?: SortOrder
    isActive?: SortOrder
    ficId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    courseCode?: StringWithAggregatesFilter<"Class"> | string
    section?: StringWithAggregatesFilter<"Class"> | string
    semester?: StringWithAggregatesFilter<"Class"> | string
    isActive?: BoolWithAggregatesFilter<"Class"> | boolean
    ficId?: StringWithAggregatesFilter<"Class"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type UserClassEnrollmentWhereInput = {
    AND?: UserClassEnrollmentWhereInput | UserClassEnrollmentWhereInput[]
    OR?: UserClassEnrollmentWhereInput[]
    NOT?: UserClassEnrollmentWhereInput | UserClassEnrollmentWhereInput[]
    id?: StringFilter<"UserClassEnrollment"> | string
    userId?: StringFilter<"UserClassEnrollment"> | string
    classId?: StringFilter<"UserClassEnrollment"> | string
    createdAt?: DateTimeFilter<"UserClassEnrollment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type UserClassEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type UserClassEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_classId?: UserClassEnrollmentUserIdClassIdCompoundUniqueInput
    AND?: UserClassEnrollmentWhereInput | UserClassEnrollmentWhereInput[]
    OR?: UserClassEnrollmentWhereInput[]
    NOT?: UserClassEnrollmentWhereInput | UserClassEnrollmentWhereInput[]
    userId?: StringFilter<"UserClassEnrollment"> | string
    classId?: StringFilter<"UserClassEnrollment"> | string
    createdAt?: DateTimeFilter<"UserClassEnrollment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "id" | "userId_classId">

  export type UserClassEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
    _count?: UserClassEnrollmentCountOrderByAggregateInput
    _max?: UserClassEnrollmentMaxOrderByAggregateInput
    _min?: UserClassEnrollmentMinOrderByAggregateInput
  }

  export type UserClassEnrollmentScalarWhereWithAggregatesInput = {
    AND?: UserClassEnrollmentScalarWhereWithAggregatesInput | UserClassEnrollmentScalarWhereWithAggregatesInput[]
    OR?: UserClassEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: UserClassEnrollmentScalarWhereWithAggregatesInput | UserClassEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserClassEnrollment"> | string
    userId?: StringWithAggregatesFilter<"UserClassEnrollment"> | string
    classId?: StringWithAggregatesFilter<"UserClassEnrollment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserClassEnrollment"> | Date | string
  }

  export type BorrowWhereInput = {
    AND?: BorrowWhereInput | BorrowWhereInput[]
    OR?: BorrowWhereInput[]
    NOT?: BorrowWhereInput | BorrowWhereInput[]
    id?: StringFilter<"Borrow"> | string
    requestSubmissionTime?: DateTimeFilter<"Borrow"> | Date | string
    requestedStartDate?: DateTimeFilter<"Borrow"> | Date | string
    borrowerId?: StringFilter<"Borrow"> | string
    classId?: StringFilter<"Borrow"> | string
    ficId?: StringNullableFilter<"Borrow"> | string | null
    equipmentId?: StringFilter<"Borrow"> | string
    borrowStatus?: EnumBorrowStatusFilter<"Borrow"> | $Enums.BorrowStatus
    approvedByFicId?: StringNullableFilter<"Borrow"> | string | null
    approvedByStaffId?: StringNullableFilter<"Borrow"> | string | null
    checkoutTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    expectedReturnTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    actualReturnTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    returnCondition?: StringNullableFilter<"Borrow"> | string | null
    returnRemarks?: StringNullableFilter<"Borrow"> | string | null
    editHistory?: JsonNullableListFilter<"Borrow">
    createdAt?: DateTimeFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeFilter<"Borrow"> | Date | string
    borrower?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    fic?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    groupMates?: BorrowGroupMateListRelationFilter
    approvedByFic?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedByStaff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deficiencies?: DeficiencyListRelationFilter
  }

  export type BorrowOrderByWithRelationInput = {
    id?: SortOrder
    requestSubmissionTime?: SortOrder
    requestedStartDate?: SortOrder
    borrowerId?: SortOrder
    classId?: SortOrder
    ficId?: SortOrder
    equipmentId?: SortOrder
    borrowStatus?: SortOrder
    approvedByFicId?: SortOrder
    approvedByStaffId?: SortOrder
    checkoutTime?: SortOrder
    expectedReturnTime?: SortOrder
    actualReturnTime?: SortOrder
    returnCondition?: SortOrder
    returnRemarks?: SortOrder
    editHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrower?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    fic?: UserOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
    groupMates?: BorrowGroupMateOrderByRelationAggregateInput
    approvedByFic?: UserOrderByWithRelationInput
    approvedByStaff?: UserOrderByWithRelationInput
    deficiencies?: DeficiencyOrderByRelationAggregateInput
  }

  export type BorrowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BorrowWhereInput | BorrowWhereInput[]
    OR?: BorrowWhereInput[]
    NOT?: BorrowWhereInput | BorrowWhereInput[]
    requestSubmissionTime?: DateTimeFilter<"Borrow"> | Date | string
    requestedStartDate?: DateTimeFilter<"Borrow"> | Date | string
    borrowerId?: StringFilter<"Borrow"> | string
    classId?: StringFilter<"Borrow"> | string
    ficId?: StringNullableFilter<"Borrow"> | string | null
    equipmentId?: StringFilter<"Borrow"> | string
    borrowStatus?: EnumBorrowStatusFilter<"Borrow"> | $Enums.BorrowStatus
    approvedByFicId?: StringNullableFilter<"Borrow"> | string | null
    approvedByStaffId?: StringNullableFilter<"Borrow"> | string | null
    checkoutTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    expectedReturnTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    actualReturnTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    returnCondition?: StringNullableFilter<"Borrow"> | string | null
    returnRemarks?: StringNullableFilter<"Borrow"> | string | null
    editHistory?: JsonNullableListFilter<"Borrow">
    createdAt?: DateTimeFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeFilter<"Borrow"> | Date | string
    borrower?: XOR<UserScalarRelationFilter, UserWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
    fic?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    groupMates?: BorrowGroupMateListRelationFilter
    approvedByFic?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedByStaff?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    deficiencies?: DeficiencyListRelationFilter
  }, "id">

  export type BorrowOrderByWithAggregationInput = {
    id?: SortOrder
    requestSubmissionTime?: SortOrder
    requestedStartDate?: SortOrder
    borrowerId?: SortOrder
    classId?: SortOrder
    ficId?: SortOrder
    equipmentId?: SortOrder
    borrowStatus?: SortOrder
    approvedByFicId?: SortOrder
    approvedByStaffId?: SortOrder
    checkoutTime?: SortOrder
    expectedReturnTime?: SortOrder
    actualReturnTime?: SortOrder
    returnCondition?: SortOrder
    returnRemarks?: SortOrder
    editHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BorrowCountOrderByAggregateInput
    _max?: BorrowMaxOrderByAggregateInput
    _min?: BorrowMinOrderByAggregateInput
  }

  export type BorrowScalarWhereWithAggregatesInput = {
    AND?: BorrowScalarWhereWithAggregatesInput | BorrowScalarWhereWithAggregatesInput[]
    OR?: BorrowScalarWhereWithAggregatesInput[]
    NOT?: BorrowScalarWhereWithAggregatesInput | BorrowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Borrow"> | string
    requestSubmissionTime?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
    requestedStartDate?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
    borrowerId?: StringWithAggregatesFilter<"Borrow"> | string
    classId?: StringWithAggregatesFilter<"Borrow"> | string
    ficId?: StringNullableWithAggregatesFilter<"Borrow"> | string | null
    equipmentId?: StringWithAggregatesFilter<"Borrow"> | string
    borrowStatus?: EnumBorrowStatusWithAggregatesFilter<"Borrow"> | $Enums.BorrowStatus
    approvedByFicId?: StringNullableWithAggregatesFilter<"Borrow"> | string | null
    approvedByStaffId?: StringNullableWithAggregatesFilter<"Borrow"> | string | null
    checkoutTime?: DateTimeNullableWithAggregatesFilter<"Borrow"> | Date | string | null
    expectedReturnTime?: DateTimeNullableWithAggregatesFilter<"Borrow"> | Date | string | null
    actualReturnTime?: DateTimeNullableWithAggregatesFilter<"Borrow"> | Date | string | null
    returnCondition?: StringNullableWithAggregatesFilter<"Borrow"> | string | null
    returnRemarks?: StringNullableWithAggregatesFilter<"Borrow"> | string | null
    editHistory?: JsonNullableListFilter<"Borrow">
    createdAt?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Borrow"> | Date | string
  }

  export type BorrowGroupMateWhereInput = {
    AND?: BorrowGroupMateWhereInput | BorrowGroupMateWhereInput[]
    OR?: BorrowGroupMateWhereInput[]
    NOT?: BorrowGroupMateWhereInput | BorrowGroupMateWhereInput[]
    id?: StringFilter<"BorrowGroupMate"> | string
    borrowId?: StringFilter<"BorrowGroupMate"> | string
    userId?: StringFilter<"BorrowGroupMate"> | string
    createdAt?: DateTimeFilter<"BorrowGroupMate"> | Date | string
    borrow?: XOR<BorrowScalarRelationFilter, BorrowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BorrowGroupMateOrderByWithRelationInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    borrow?: BorrowOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BorrowGroupMateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    borrowId_userId?: BorrowGroupMateBorrowIdUserIdCompoundUniqueInput
    AND?: BorrowGroupMateWhereInput | BorrowGroupMateWhereInput[]
    OR?: BorrowGroupMateWhereInput[]
    NOT?: BorrowGroupMateWhereInput | BorrowGroupMateWhereInput[]
    borrowId?: StringFilter<"BorrowGroupMate"> | string
    userId?: StringFilter<"BorrowGroupMate"> | string
    createdAt?: DateTimeFilter<"BorrowGroupMate"> | Date | string
    borrow?: XOR<BorrowScalarRelationFilter, BorrowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "borrowId_userId">

  export type BorrowGroupMateOrderByWithAggregationInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: BorrowGroupMateCountOrderByAggregateInput
    _max?: BorrowGroupMateMaxOrderByAggregateInput
    _min?: BorrowGroupMateMinOrderByAggregateInput
  }

  export type BorrowGroupMateScalarWhereWithAggregatesInput = {
    AND?: BorrowGroupMateScalarWhereWithAggregatesInput | BorrowGroupMateScalarWhereWithAggregatesInput[]
    OR?: BorrowGroupMateScalarWhereWithAggregatesInput[]
    NOT?: BorrowGroupMateScalarWhereWithAggregatesInput | BorrowGroupMateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BorrowGroupMate"> | string
    borrowId?: StringWithAggregatesFilter<"BorrowGroupMate"> | string
    userId?: StringWithAggregatesFilter<"BorrowGroupMate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BorrowGroupMate"> | Date | string
  }

  export type DeficiencyWhereInput = {
    AND?: DeficiencyWhereInput | DeficiencyWhereInput[]
    OR?: DeficiencyWhereInput[]
    NOT?: DeficiencyWhereInput | DeficiencyWhereInput[]
    id?: StringFilter<"Deficiency"> | string
    borrowId?: StringFilter<"Deficiency"> | string
    userId?: StringFilter<"Deficiency"> | string
    taggedById?: StringFilter<"Deficiency"> | string
    ficToNotifyId?: StringNullableFilter<"Deficiency"> | string | null
    type?: EnumDeficiencyTypeFilter<"Deficiency"> | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFilter<"Deficiency"> | $Enums.DeficiencyStatus
    description?: StringNullableFilter<"Deficiency"> | string | null
    resolution?: StringNullableFilter<"Deficiency"> | string | null
    createdAt?: DateTimeFilter<"Deficiency"> | Date | string
    updatedAt?: DateTimeFilter<"Deficiency"> | Date | string
    borrow?: XOR<BorrowScalarRelationFilter, BorrowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    taggedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ficToNotify?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DeficiencyOrderByWithRelationInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    taggedById?: SortOrder
    ficToNotifyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    borrow?: BorrowOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    taggedBy?: UserOrderByWithRelationInput
    ficToNotify?: UserOrderByWithRelationInput
  }

  export type DeficiencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeficiencyWhereInput | DeficiencyWhereInput[]
    OR?: DeficiencyWhereInput[]
    NOT?: DeficiencyWhereInput | DeficiencyWhereInput[]
    borrowId?: StringFilter<"Deficiency"> | string
    userId?: StringFilter<"Deficiency"> | string
    taggedById?: StringFilter<"Deficiency"> | string
    ficToNotifyId?: StringNullableFilter<"Deficiency"> | string | null
    type?: EnumDeficiencyTypeFilter<"Deficiency"> | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFilter<"Deficiency"> | $Enums.DeficiencyStatus
    description?: StringNullableFilter<"Deficiency"> | string | null
    resolution?: StringNullableFilter<"Deficiency"> | string | null
    createdAt?: DateTimeFilter<"Deficiency"> | Date | string
    updatedAt?: DateTimeFilter<"Deficiency"> | Date | string
    borrow?: XOR<BorrowScalarRelationFilter, BorrowWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    taggedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    ficToNotify?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DeficiencyOrderByWithAggregationInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    taggedById?: SortOrder
    ficToNotifyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeficiencyCountOrderByAggregateInput
    _max?: DeficiencyMaxOrderByAggregateInput
    _min?: DeficiencyMinOrderByAggregateInput
  }

  export type DeficiencyScalarWhereWithAggregatesInput = {
    AND?: DeficiencyScalarWhereWithAggregatesInput | DeficiencyScalarWhereWithAggregatesInput[]
    OR?: DeficiencyScalarWhereWithAggregatesInput[]
    NOT?: DeficiencyScalarWhereWithAggregatesInput | DeficiencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deficiency"> | string
    borrowId?: StringWithAggregatesFilter<"Deficiency"> | string
    userId?: StringWithAggregatesFilter<"Deficiency"> | string
    taggedById?: StringWithAggregatesFilter<"Deficiency"> | string
    ficToNotifyId?: StringNullableWithAggregatesFilter<"Deficiency"> | string | null
    type?: EnumDeficiencyTypeWithAggregatesFilter<"Deficiency"> | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusWithAggregatesFilter<"Deficiency"> | $Enums.DeficiencyStatus
    description?: StringNullableWithAggregatesFilter<"Deficiency"> | string | null
    resolution?: StringNullableWithAggregatesFilter<"Deficiency"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deficiency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deficiency"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentCreateInput = {
    id?: string
    name: string
    equipmentId?: string | null
    qrCodeValue?: string
    category?: $Enums.EquipmentCategory
    condition?: string | null
    status?: $Enums.EquipmentStatus
    stockCount?: number
    purchaseCost?: number | null
    images?: EquipmentCreateimagesInput | string[]
    editHistory?: EquipmentCreateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentCreatemaintenanceLogInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowRecords?: BorrowCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    name: string
    equipmentId?: string | null
    qrCodeValue?: string
    category?: $Enums.EquipmentCategory
    condition?: string | null
    status?: $Enums.EquipmentStatus
    stockCount?: number
    purchaseCost?: number | null
    images?: EquipmentCreateimagesInput | string[]
    editHistory?: EquipmentCreateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentCreatemaintenanceLogInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowRecords?: BorrowUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeValue?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentCategoryFieldUpdateOperationsInput | $Enums.EquipmentCategory
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    stockCount?: IntFieldUpdateOperationsInput | number
    purchaseCost?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: EquipmentUpdateimagesInput | string[]
    editHistory?: EquipmentUpdateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentUpdatemaintenanceLogInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowRecords?: BorrowUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeValue?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentCategoryFieldUpdateOperationsInput | $Enums.EquipmentCategory
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    stockCount?: IntFieldUpdateOperationsInput | number
    purchaseCost?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: EquipmentUpdateimagesInput | string[]
    editHistory?: EquipmentUpdateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentUpdatemaintenanceLogInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowRecords?: BorrowUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    name: string
    equipmentId?: string | null
    qrCodeValue?: string
    category?: $Enums.EquipmentCategory
    condition?: string | null
    status?: $Enums.EquipmentStatus
    stockCount?: number
    purchaseCost?: number | null
    images?: EquipmentCreateimagesInput | string[]
    editHistory?: EquipmentCreateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentCreatemaintenanceLogInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeValue?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentCategoryFieldUpdateOperationsInput | $Enums.EquipmentCategory
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    stockCount?: IntFieldUpdateOperationsInput | number
    purchaseCost?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: EquipmentUpdateimagesInput | string[]
    editHistory?: EquipmentUpdateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentUpdatemaintenanceLogInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeValue?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentCategoryFieldUpdateOperationsInput | $Enums.EquipmentCategory
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    stockCount?: IntFieldUpdateOperationsInput | number
    purchaseCost?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: EquipmentUpdateimagesInput | string[]
    editHistory?: EquipmentUpdateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentUpdatemaintenanceLogInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fic: UserCreateNestedOneWithoutClassesTaughtInput
    enrollments?: UserClassEnrollmentCreateNestedManyWithoutClassInput
    borrowRequests?: BorrowCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    ficId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: UserClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    borrowRequests?: BorrowUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fic?: UserUpdateOneRequiredWithoutClassesTaughtNestedInput
    enrollments?: UserClassEnrollmentUpdateManyWithoutClassNestedInput
    borrowRequests?: BorrowUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ficId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: UserClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    borrowRequests?: BorrowUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    ficId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ficId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutClassesEnrolledInput
    class: ClassCreateNestedOneWithoutEnrollmentsInput
  }

  export type UserClassEnrollmentUncheckedCreateInput = {
    id?: string
    userId: string
    classId: string
    createdAt?: Date | string
  }

  export type UserClassEnrollmentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClassesEnrolledNestedInput
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type UserClassEnrollmentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentCreateManyInput = {
    id?: string
    userId: string
    classId: string
    createdAt?: Date | string
  }

  export type UserClassEnrollmentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowCreateInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUpdateInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowCreateManyInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowUpdateManyMutationInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUncheckedUpdateManyInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateCreateInput = {
    id?: string
    createdAt?: Date | string
    borrow: BorrowCreateNestedOneWithoutGroupMatesInput
    user: UserCreateNestedOneWithoutGroupBorrowMembershipInput
  }

  export type BorrowGroupMateUncheckedCreateInput = {
    id?: string
    borrowId: string
    userId: string
    createdAt?: Date | string
  }

  export type BorrowGroupMateUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrow?: BorrowUpdateOneRequiredWithoutGroupMatesNestedInput
    user?: UserUpdateOneRequiredWithoutGroupBorrowMembershipNestedInput
  }

  export type BorrowGroupMateUncheckedUpdateInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateCreateManyInput = {
    id?: string
    borrowId: string
    userId: string
    createdAt?: Date | string
  }

  export type BorrowGroupMateUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateUncheckedUpdateManyInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyCreateInput = {
    id?: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    borrow: BorrowCreateNestedOneWithoutDeficienciesInput
    user: UserCreateNestedOneWithoutUserDeficienciesInput
    taggedBy: UserCreateNestedOneWithoutTaggedDeficienciesInput
    ficToNotify?: UserCreateNestedOneWithoutNotifiedFicDeficienciesInput
  }

  export type DeficiencyUncheckedCreateInput = {
    id?: string
    borrowId: string
    userId: string
    taggedById: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyUpdateInput = {
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrow?: BorrowUpdateOneRequiredWithoutDeficienciesNestedInput
    user?: UserUpdateOneRequiredWithoutUserDeficienciesNestedInput
    taggedBy?: UserUpdateOneRequiredWithoutTaggedDeficienciesNestedInput
    ficToNotify?: UserUpdateOneWithoutNotifiedFicDeficienciesNestedInput
  }

  export type DeficiencyUncheckedUpdateInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyCreateManyInput = {
    id?: string
    borrowId: string
    userId: string
    taggedById: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyUpdateManyMutationInput = {
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUncheckedUpdateManyInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type UserClassEnrollmentListRelationFilter = {
    every?: UserClassEnrollmentWhereInput
    some?: UserClassEnrollmentWhereInput
    none?: UserClassEnrollmentWhereInput
  }

  export type BorrowListRelationFilter = {
    every?: BorrowWhereInput
    some?: BorrowWhereInput
    none?: BorrowWhereInput
  }

  export type BorrowGroupMateListRelationFilter = {
    every?: BorrowGroupMateWhereInput
    some?: BorrowGroupMateWhereInput
    none?: BorrowGroupMateWhereInput
  }

  export type DeficiencyListRelationFilter = {
    every?: DeficiencyWhereInput
    some?: DeficiencyWhereInput
    none?: DeficiencyWhereInput
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserClassEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BorrowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BorrowGroupMateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeficiencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    studentNumber?: SortOrder
    contactNumber?: SortOrder
    sex?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    studentNumber?: SortOrder
    contactNumber?: SortOrder
    sex?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    studentNumber?: SortOrder
    contactNumber?: SortOrder
    sex?: SortOrder
    password?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumEquipmentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCategory | EnumEquipmentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentCategoryFilter<$PrismaModel> | $Enums.EquipmentCategory
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableListFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableListFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableListFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableListFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableListFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel> | null
    has?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    hasEvery?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    hasSome?: InputJsonValue[] | ListJsonFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    equipmentId?: SortOrder
    qrCodeValue?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    stockCount?: SortOrder
    purchaseCost?: SortOrder
    images?: SortOrder
    editHistory?: SortOrder
    maintenanceLog?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    stockCount?: SortOrder
    purchaseCost?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    equipmentId?: SortOrder
    qrCodeValue?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    stockCount?: SortOrder
    purchaseCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    equipmentId?: SortOrder
    qrCodeValue?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    status?: SortOrder
    stockCount?: SortOrder
    purchaseCost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    stockCount?: SortOrder
    purchaseCost?: SortOrder
  }

  export type EnumEquipmentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCategory | EnumEquipmentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentCategoryFilter<$PrismaModel>
    _max?: NestedEnumEquipmentCategoryFilter<$PrismaModel>
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClassCourseCodeSectionSemesterCompoundUniqueInput = {
    courseCode: string
    section: string
    semester: string
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    courseCode?: SortOrder
    section?: SortOrder
    semester?: SortOrder
    isActive?: SortOrder
    ficId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    courseCode?: SortOrder
    section?: SortOrder
    semester?: SortOrder
    isActive?: SortOrder
    ficId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    courseCode?: SortOrder
    section?: SortOrder
    semester?: SortOrder
    isActive?: SortOrder
    ficId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type UserClassEnrollmentUserIdClassIdCompoundUniqueInput = {
    userId: string
    classId: string
  }

  export type UserClassEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserClassEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserClassEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBorrowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBorrowStatusFilter<$PrismaModel> | $Enums.BorrowStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type BorrowCountOrderByAggregateInput = {
    id?: SortOrder
    requestSubmissionTime?: SortOrder
    requestedStartDate?: SortOrder
    borrowerId?: SortOrder
    classId?: SortOrder
    ficId?: SortOrder
    equipmentId?: SortOrder
    borrowStatus?: SortOrder
    approvedByFicId?: SortOrder
    approvedByStaffId?: SortOrder
    checkoutTime?: SortOrder
    expectedReturnTime?: SortOrder
    actualReturnTime?: SortOrder
    returnCondition?: SortOrder
    returnRemarks?: SortOrder
    editHistory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowMaxOrderByAggregateInput = {
    id?: SortOrder
    requestSubmissionTime?: SortOrder
    requestedStartDate?: SortOrder
    borrowerId?: SortOrder
    classId?: SortOrder
    ficId?: SortOrder
    equipmentId?: SortOrder
    borrowStatus?: SortOrder
    approvedByFicId?: SortOrder
    approvedByStaffId?: SortOrder
    checkoutTime?: SortOrder
    expectedReturnTime?: SortOrder
    actualReturnTime?: SortOrder
    returnCondition?: SortOrder
    returnRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BorrowMinOrderByAggregateInput = {
    id?: SortOrder
    requestSubmissionTime?: SortOrder
    requestedStartDate?: SortOrder
    borrowerId?: SortOrder
    classId?: SortOrder
    ficId?: SortOrder
    equipmentId?: SortOrder
    borrowStatus?: SortOrder
    approvedByFicId?: SortOrder
    approvedByStaffId?: SortOrder
    checkoutTime?: SortOrder
    expectedReturnTime?: SortOrder
    actualReturnTime?: SortOrder
    returnCondition?: SortOrder
    returnRemarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBorrowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBorrowStatusWithAggregatesFilter<$PrismaModel> | $Enums.BorrowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBorrowStatusFilter<$PrismaModel>
    _max?: NestedEnumBorrowStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BorrowScalarRelationFilter = {
    is?: BorrowWhereInput
    isNot?: BorrowWhereInput
  }

  export type BorrowGroupMateBorrowIdUserIdCompoundUniqueInput = {
    borrowId: string
    userId: string
  }

  export type BorrowGroupMateCountOrderByAggregateInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BorrowGroupMateMaxOrderByAggregateInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type BorrowGroupMateMinOrderByAggregateInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDeficiencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyType | EnumDeficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyTypeFilter<$PrismaModel> | $Enums.DeficiencyType
  }

  export type EnumDeficiencyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyStatus | EnumDeficiencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyStatusFilter<$PrismaModel> | $Enums.DeficiencyStatus
  }

  export type DeficiencyCountOrderByAggregateInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    taggedById?: SortOrder
    ficToNotifyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeficiencyMaxOrderByAggregateInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    taggedById?: SortOrder
    ficToNotifyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeficiencyMinOrderByAggregateInput = {
    id?: SortOrder
    borrowId?: SortOrder
    userId?: SortOrder
    taggedById?: SortOrder
    ficToNotifyId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    description?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeficiencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyType | EnumDeficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeficiencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeficiencyTypeFilter<$PrismaModel>
    _max?: NestedEnumDeficiencyTypeFilter<$PrismaModel>
  }

  export type EnumDeficiencyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyStatus | EnumDeficiencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeficiencyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeficiencyStatusFilter<$PrismaModel>
    _max?: NestedEnumDeficiencyStatusFilter<$PrismaModel>
  }

  export type ClassCreateNestedManyWithoutFicInput = {
    create?: XOR<ClassCreateWithoutFicInput, ClassUncheckedCreateWithoutFicInput> | ClassCreateWithoutFicInput[] | ClassUncheckedCreateWithoutFicInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutFicInput | ClassCreateOrConnectWithoutFicInput[]
    createMany?: ClassCreateManyFicInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type UserClassEnrollmentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutUserInput, UserClassEnrollmentUncheckedCreateWithoutUserInput> | UserClassEnrollmentCreateWithoutUserInput[] | UserClassEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutUserInput | UserClassEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: UserClassEnrollmentCreateManyUserInputEnvelope
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
  }

  export type BorrowCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<BorrowCreateWithoutBorrowerInput, BorrowUncheckedCreateWithoutBorrowerInput> | BorrowCreateWithoutBorrowerInput[] | BorrowUncheckedCreateWithoutBorrowerInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBorrowerInput | BorrowCreateOrConnectWithoutBorrowerInput[]
    createMany?: BorrowCreateManyBorrowerInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowCreateNestedManyWithoutFicInput = {
    create?: XOR<BorrowCreateWithoutFicInput, BorrowUncheckedCreateWithoutFicInput> | BorrowCreateWithoutFicInput[] | BorrowUncheckedCreateWithoutFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutFicInput | BorrowCreateOrConnectWithoutFicInput[]
    createMany?: BorrowCreateManyFicInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowCreateNestedManyWithoutApprovedByFicInput = {
    create?: XOR<BorrowCreateWithoutApprovedByFicInput, BorrowUncheckedCreateWithoutApprovedByFicInput> | BorrowCreateWithoutApprovedByFicInput[] | BorrowUncheckedCreateWithoutApprovedByFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByFicInput | BorrowCreateOrConnectWithoutApprovedByFicInput[]
    createMany?: BorrowCreateManyApprovedByFicInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowCreateNestedManyWithoutApprovedByStaffInput = {
    create?: XOR<BorrowCreateWithoutApprovedByStaffInput, BorrowUncheckedCreateWithoutApprovedByStaffInput> | BorrowCreateWithoutApprovedByStaffInput[] | BorrowUncheckedCreateWithoutApprovedByStaffInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByStaffInput | BorrowCreateOrConnectWithoutApprovedByStaffInput[]
    createMany?: BorrowCreateManyApprovedByStaffInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowGroupMateCreateNestedManyWithoutUserInput = {
    create?: XOR<BorrowGroupMateCreateWithoutUserInput, BorrowGroupMateUncheckedCreateWithoutUserInput> | BorrowGroupMateCreateWithoutUserInput[] | BorrowGroupMateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutUserInput | BorrowGroupMateCreateOrConnectWithoutUserInput[]
    createMany?: BorrowGroupMateCreateManyUserInputEnvelope
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
  }

  export type DeficiencyCreateNestedManyWithoutUserInput = {
    create?: XOR<DeficiencyCreateWithoutUserInput, DeficiencyUncheckedCreateWithoutUserInput> | DeficiencyCreateWithoutUserInput[] | DeficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutUserInput | DeficiencyCreateOrConnectWithoutUserInput[]
    createMany?: DeficiencyCreateManyUserInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type DeficiencyCreateNestedManyWithoutTaggedByInput = {
    create?: XOR<DeficiencyCreateWithoutTaggedByInput, DeficiencyUncheckedCreateWithoutTaggedByInput> | DeficiencyCreateWithoutTaggedByInput[] | DeficiencyUncheckedCreateWithoutTaggedByInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutTaggedByInput | DeficiencyCreateOrConnectWithoutTaggedByInput[]
    createMany?: DeficiencyCreateManyTaggedByInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type DeficiencyCreateNestedManyWithoutFicToNotifyInput = {
    create?: XOR<DeficiencyCreateWithoutFicToNotifyInput, DeficiencyUncheckedCreateWithoutFicToNotifyInput> | DeficiencyCreateWithoutFicToNotifyInput[] | DeficiencyUncheckedCreateWithoutFicToNotifyInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutFicToNotifyInput | DeficiencyCreateOrConnectWithoutFicToNotifyInput[]
    createMany?: DeficiencyCreateManyFicToNotifyInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutFicInput = {
    create?: XOR<ClassCreateWithoutFicInput, ClassUncheckedCreateWithoutFicInput> | ClassCreateWithoutFicInput[] | ClassUncheckedCreateWithoutFicInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutFicInput | ClassCreateOrConnectWithoutFicInput[]
    createMany?: ClassCreateManyFicInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutUserInput, UserClassEnrollmentUncheckedCreateWithoutUserInput> | UserClassEnrollmentCreateWithoutUserInput[] | UserClassEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutUserInput | UserClassEnrollmentCreateOrConnectWithoutUserInput[]
    createMany?: UserClassEnrollmentCreateManyUserInputEnvelope
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutBorrowerInput = {
    create?: XOR<BorrowCreateWithoutBorrowerInput, BorrowUncheckedCreateWithoutBorrowerInput> | BorrowCreateWithoutBorrowerInput[] | BorrowUncheckedCreateWithoutBorrowerInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBorrowerInput | BorrowCreateOrConnectWithoutBorrowerInput[]
    createMany?: BorrowCreateManyBorrowerInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutFicInput = {
    create?: XOR<BorrowCreateWithoutFicInput, BorrowUncheckedCreateWithoutFicInput> | BorrowCreateWithoutFicInput[] | BorrowUncheckedCreateWithoutFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutFicInput | BorrowCreateOrConnectWithoutFicInput[]
    createMany?: BorrowCreateManyFicInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput = {
    create?: XOR<BorrowCreateWithoutApprovedByFicInput, BorrowUncheckedCreateWithoutApprovedByFicInput> | BorrowCreateWithoutApprovedByFicInput[] | BorrowUncheckedCreateWithoutApprovedByFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByFicInput | BorrowCreateOrConnectWithoutApprovedByFicInput[]
    createMany?: BorrowCreateManyApprovedByFicInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput = {
    create?: XOR<BorrowCreateWithoutApprovedByStaffInput, BorrowUncheckedCreateWithoutApprovedByStaffInput> | BorrowCreateWithoutApprovedByStaffInput[] | BorrowUncheckedCreateWithoutApprovedByStaffInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByStaffInput | BorrowCreateOrConnectWithoutApprovedByStaffInput[]
    createMany?: BorrowCreateManyApprovedByStaffInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BorrowGroupMateCreateWithoutUserInput, BorrowGroupMateUncheckedCreateWithoutUserInput> | BorrowGroupMateCreateWithoutUserInput[] | BorrowGroupMateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutUserInput | BorrowGroupMateCreateOrConnectWithoutUserInput[]
    createMany?: BorrowGroupMateCreateManyUserInputEnvelope
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
  }

  export type DeficiencyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeficiencyCreateWithoutUserInput, DeficiencyUncheckedCreateWithoutUserInput> | DeficiencyCreateWithoutUserInput[] | DeficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutUserInput | DeficiencyCreateOrConnectWithoutUserInput[]
    createMany?: DeficiencyCreateManyUserInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput = {
    create?: XOR<DeficiencyCreateWithoutTaggedByInput, DeficiencyUncheckedCreateWithoutTaggedByInput> | DeficiencyCreateWithoutTaggedByInput[] | DeficiencyUncheckedCreateWithoutTaggedByInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutTaggedByInput | DeficiencyCreateOrConnectWithoutTaggedByInput[]
    createMany?: DeficiencyCreateManyTaggedByInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput = {
    create?: XOR<DeficiencyCreateWithoutFicToNotifyInput, DeficiencyUncheckedCreateWithoutFicToNotifyInput> | DeficiencyCreateWithoutFicToNotifyInput[] | DeficiencyUncheckedCreateWithoutFicToNotifyInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutFicToNotifyInput | DeficiencyCreateOrConnectWithoutFicToNotifyInput[]
    createMany?: DeficiencyCreateManyFicToNotifyInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClassUpdateManyWithoutFicNestedInput = {
    create?: XOR<ClassCreateWithoutFicInput, ClassUncheckedCreateWithoutFicInput> | ClassCreateWithoutFicInput[] | ClassUncheckedCreateWithoutFicInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutFicInput | ClassCreateOrConnectWithoutFicInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutFicInput | ClassUpsertWithWhereUniqueWithoutFicInput[]
    createMany?: ClassCreateManyFicInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutFicInput | ClassUpdateWithWhereUniqueWithoutFicInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutFicInput | ClassUpdateManyWithWhereWithoutFicInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserClassEnrollmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutUserInput, UserClassEnrollmentUncheckedCreateWithoutUserInput> | UserClassEnrollmentCreateWithoutUserInput[] | UserClassEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutUserInput | UserClassEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: UserClassEnrollmentUpsertWithWhereUniqueWithoutUserInput | UserClassEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserClassEnrollmentCreateManyUserInputEnvelope
    set?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    disconnect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    delete?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    update?: UserClassEnrollmentUpdateWithWhereUniqueWithoutUserInput | UserClassEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserClassEnrollmentUpdateManyWithWhereWithoutUserInput | UserClassEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserClassEnrollmentScalarWhereInput | UserClassEnrollmentScalarWhereInput[]
  }

  export type BorrowUpdateManyWithoutBorrowerNestedInput = {
    create?: XOR<BorrowCreateWithoutBorrowerInput, BorrowUncheckedCreateWithoutBorrowerInput> | BorrowCreateWithoutBorrowerInput[] | BorrowUncheckedCreateWithoutBorrowerInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBorrowerInput | BorrowCreateOrConnectWithoutBorrowerInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutBorrowerInput | BorrowUpsertWithWhereUniqueWithoutBorrowerInput[]
    createMany?: BorrowCreateManyBorrowerInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutBorrowerInput | BorrowUpdateWithWhereUniqueWithoutBorrowerInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutBorrowerInput | BorrowUpdateManyWithWhereWithoutBorrowerInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUpdateManyWithoutFicNestedInput = {
    create?: XOR<BorrowCreateWithoutFicInput, BorrowUncheckedCreateWithoutFicInput> | BorrowCreateWithoutFicInput[] | BorrowUncheckedCreateWithoutFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutFicInput | BorrowCreateOrConnectWithoutFicInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutFicInput | BorrowUpsertWithWhereUniqueWithoutFicInput[]
    createMany?: BorrowCreateManyFicInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutFicInput | BorrowUpdateWithWhereUniqueWithoutFicInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutFicInput | BorrowUpdateManyWithWhereWithoutFicInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUpdateManyWithoutApprovedByFicNestedInput = {
    create?: XOR<BorrowCreateWithoutApprovedByFicInput, BorrowUncheckedCreateWithoutApprovedByFicInput> | BorrowCreateWithoutApprovedByFicInput[] | BorrowUncheckedCreateWithoutApprovedByFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByFicInput | BorrowCreateOrConnectWithoutApprovedByFicInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutApprovedByFicInput | BorrowUpsertWithWhereUniqueWithoutApprovedByFicInput[]
    createMany?: BorrowCreateManyApprovedByFicInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutApprovedByFicInput | BorrowUpdateWithWhereUniqueWithoutApprovedByFicInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutApprovedByFicInput | BorrowUpdateManyWithWhereWithoutApprovedByFicInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUpdateManyWithoutApprovedByStaffNestedInput = {
    create?: XOR<BorrowCreateWithoutApprovedByStaffInput, BorrowUncheckedCreateWithoutApprovedByStaffInput> | BorrowCreateWithoutApprovedByStaffInput[] | BorrowUncheckedCreateWithoutApprovedByStaffInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByStaffInput | BorrowCreateOrConnectWithoutApprovedByStaffInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutApprovedByStaffInput | BorrowUpsertWithWhereUniqueWithoutApprovedByStaffInput[]
    createMany?: BorrowCreateManyApprovedByStaffInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutApprovedByStaffInput | BorrowUpdateWithWhereUniqueWithoutApprovedByStaffInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutApprovedByStaffInput | BorrowUpdateManyWithWhereWithoutApprovedByStaffInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowGroupMateUpdateManyWithoutUserNestedInput = {
    create?: XOR<BorrowGroupMateCreateWithoutUserInput, BorrowGroupMateUncheckedCreateWithoutUserInput> | BorrowGroupMateCreateWithoutUserInput[] | BorrowGroupMateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutUserInput | BorrowGroupMateCreateOrConnectWithoutUserInput[]
    upsert?: BorrowGroupMateUpsertWithWhereUniqueWithoutUserInput | BorrowGroupMateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BorrowGroupMateCreateManyUserInputEnvelope
    set?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    disconnect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    delete?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    update?: BorrowGroupMateUpdateWithWhereUniqueWithoutUserInput | BorrowGroupMateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BorrowGroupMateUpdateManyWithWhereWithoutUserInput | BorrowGroupMateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BorrowGroupMateScalarWhereInput | BorrowGroupMateScalarWhereInput[]
  }

  export type DeficiencyUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeficiencyCreateWithoutUserInput, DeficiencyUncheckedCreateWithoutUserInput> | DeficiencyCreateWithoutUserInput[] | DeficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutUserInput | DeficiencyCreateOrConnectWithoutUserInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutUserInput | DeficiencyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeficiencyCreateManyUserInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutUserInput | DeficiencyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutUserInput | DeficiencyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type DeficiencyUpdateManyWithoutTaggedByNestedInput = {
    create?: XOR<DeficiencyCreateWithoutTaggedByInput, DeficiencyUncheckedCreateWithoutTaggedByInput> | DeficiencyCreateWithoutTaggedByInput[] | DeficiencyUncheckedCreateWithoutTaggedByInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutTaggedByInput | DeficiencyCreateOrConnectWithoutTaggedByInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutTaggedByInput | DeficiencyUpsertWithWhereUniqueWithoutTaggedByInput[]
    createMany?: DeficiencyCreateManyTaggedByInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutTaggedByInput | DeficiencyUpdateWithWhereUniqueWithoutTaggedByInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutTaggedByInput | DeficiencyUpdateManyWithWhereWithoutTaggedByInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type DeficiencyUpdateManyWithoutFicToNotifyNestedInput = {
    create?: XOR<DeficiencyCreateWithoutFicToNotifyInput, DeficiencyUncheckedCreateWithoutFicToNotifyInput> | DeficiencyCreateWithoutFicToNotifyInput[] | DeficiencyUncheckedCreateWithoutFicToNotifyInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutFicToNotifyInput | DeficiencyCreateOrConnectWithoutFicToNotifyInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutFicToNotifyInput | DeficiencyUpsertWithWhereUniqueWithoutFicToNotifyInput[]
    createMany?: DeficiencyCreateManyFicToNotifyInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutFicToNotifyInput | DeficiencyUpdateWithWhereUniqueWithoutFicToNotifyInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutFicToNotifyInput | DeficiencyUpdateManyWithWhereWithoutFicToNotifyInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutFicNestedInput = {
    create?: XOR<ClassCreateWithoutFicInput, ClassUncheckedCreateWithoutFicInput> | ClassCreateWithoutFicInput[] | ClassUncheckedCreateWithoutFicInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutFicInput | ClassCreateOrConnectWithoutFicInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutFicInput | ClassUpsertWithWhereUniqueWithoutFicInput[]
    createMany?: ClassCreateManyFicInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutFicInput | ClassUpdateWithWhereUniqueWithoutFicInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutFicInput | ClassUpdateManyWithWhereWithoutFicInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutUserInput, UserClassEnrollmentUncheckedCreateWithoutUserInput> | UserClassEnrollmentCreateWithoutUserInput[] | UserClassEnrollmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutUserInput | UserClassEnrollmentCreateOrConnectWithoutUserInput[]
    upsert?: UserClassEnrollmentUpsertWithWhereUniqueWithoutUserInput | UserClassEnrollmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserClassEnrollmentCreateManyUserInputEnvelope
    set?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    disconnect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    delete?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    update?: UserClassEnrollmentUpdateWithWhereUniqueWithoutUserInput | UserClassEnrollmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserClassEnrollmentUpdateManyWithWhereWithoutUserInput | UserClassEnrollmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserClassEnrollmentScalarWhereInput | UserClassEnrollmentScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutBorrowerNestedInput = {
    create?: XOR<BorrowCreateWithoutBorrowerInput, BorrowUncheckedCreateWithoutBorrowerInput> | BorrowCreateWithoutBorrowerInput[] | BorrowUncheckedCreateWithoutBorrowerInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutBorrowerInput | BorrowCreateOrConnectWithoutBorrowerInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutBorrowerInput | BorrowUpsertWithWhereUniqueWithoutBorrowerInput[]
    createMany?: BorrowCreateManyBorrowerInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutBorrowerInput | BorrowUpdateWithWhereUniqueWithoutBorrowerInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutBorrowerInput | BorrowUpdateManyWithWhereWithoutBorrowerInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutFicNestedInput = {
    create?: XOR<BorrowCreateWithoutFicInput, BorrowUncheckedCreateWithoutFicInput> | BorrowCreateWithoutFicInput[] | BorrowUncheckedCreateWithoutFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutFicInput | BorrowCreateOrConnectWithoutFicInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutFicInput | BorrowUpsertWithWhereUniqueWithoutFicInput[]
    createMany?: BorrowCreateManyFicInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutFicInput | BorrowUpdateWithWhereUniqueWithoutFicInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutFicInput | BorrowUpdateManyWithWhereWithoutFicInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput = {
    create?: XOR<BorrowCreateWithoutApprovedByFicInput, BorrowUncheckedCreateWithoutApprovedByFicInput> | BorrowCreateWithoutApprovedByFicInput[] | BorrowUncheckedCreateWithoutApprovedByFicInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByFicInput | BorrowCreateOrConnectWithoutApprovedByFicInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutApprovedByFicInput | BorrowUpsertWithWhereUniqueWithoutApprovedByFicInput[]
    createMany?: BorrowCreateManyApprovedByFicInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutApprovedByFicInput | BorrowUpdateWithWhereUniqueWithoutApprovedByFicInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutApprovedByFicInput | BorrowUpdateManyWithWhereWithoutApprovedByFicInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput = {
    create?: XOR<BorrowCreateWithoutApprovedByStaffInput, BorrowUncheckedCreateWithoutApprovedByStaffInput> | BorrowCreateWithoutApprovedByStaffInput[] | BorrowUncheckedCreateWithoutApprovedByStaffInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutApprovedByStaffInput | BorrowCreateOrConnectWithoutApprovedByStaffInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutApprovedByStaffInput | BorrowUpsertWithWhereUniqueWithoutApprovedByStaffInput[]
    createMany?: BorrowCreateManyApprovedByStaffInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutApprovedByStaffInput | BorrowUpdateWithWhereUniqueWithoutApprovedByStaffInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutApprovedByStaffInput | BorrowUpdateManyWithWhereWithoutApprovedByStaffInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BorrowGroupMateCreateWithoutUserInput, BorrowGroupMateUncheckedCreateWithoutUserInput> | BorrowGroupMateCreateWithoutUserInput[] | BorrowGroupMateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutUserInput | BorrowGroupMateCreateOrConnectWithoutUserInput[]
    upsert?: BorrowGroupMateUpsertWithWhereUniqueWithoutUserInput | BorrowGroupMateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BorrowGroupMateCreateManyUserInputEnvelope
    set?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    disconnect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    delete?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    update?: BorrowGroupMateUpdateWithWhereUniqueWithoutUserInput | BorrowGroupMateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BorrowGroupMateUpdateManyWithWhereWithoutUserInput | BorrowGroupMateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BorrowGroupMateScalarWhereInput | BorrowGroupMateScalarWhereInput[]
  }

  export type DeficiencyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeficiencyCreateWithoutUserInput, DeficiencyUncheckedCreateWithoutUserInput> | DeficiencyCreateWithoutUserInput[] | DeficiencyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutUserInput | DeficiencyCreateOrConnectWithoutUserInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutUserInput | DeficiencyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeficiencyCreateManyUserInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutUserInput | DeficiencyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutUserInput | DeficiencyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput = {
    create?: XOR<DeficiencyCreateWithoutTaggedByInput, DeficiencyUncheckedCreateWithoutTaggedByInput> | DeficiencyCreateWithoutTaggedByInput[] | DeficiencyUncheckedCreateWithoutTaggedByInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutTaggedByInput | DeficiencyCreateOrConnectWithoutTaggedByInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutTaggedByInput | DeficiencyUpsertWithWhereUniqueWithoutTaggedByInput[]
    createMany?: DeficiencyCreateManyTaggedByInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutTaggedByInput | DeficiencyUpdateWithWhereUniqueWithoutTaggedByInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutTaggedByInput | DeficiencyUpdateManyWithWhereWithoutTaggedByInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput = {
    create?: XOR<DeficiencyCreateWithoutFicToNotifyInput, DeficiencyUncheckedCreateWithoutFicToNotifyInput> | DeficiencyCreateWithoutFicToNotifyInput[] | DeficiencyUncheckedCreateWithoutFicToNotifyInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutFicToNotifyInput | DeficiencyCreateOrConnectWithoutFicToNotifyInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutFicToNotifyInput | DeficiencyUpsertWithWhereUniqueWithoutFicToNotifyInput[]
    createMany?: DeficiencyCreateManyFicToNotifyInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutFicToNotifyInput | DeficiencyUpdateWithWhereUniqueWithoutFicToNotifyInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutFicToNotifyInput | DeficiencyUpdateManyWithWhereWithoutFicToNotifyInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type EquipmentCreateimagesInput = {
    set: string[]
  }

  export type EquipmentCreateeditHistoryInput = {
    set: InputJsonValue[]
  }

  export type EquipmentCreatemaintenanceLogInput = {
    set: InputJsonValue[]
  }

  export type BorrowCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<BorrowCreateWithoutEquipmentInput, BorrowUncheckedCreateWithoutEquipmentInput> | BorrowCreateWithoutEquipmentInput[] | BorrowUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutEquipmentInput | BorrowCreateOrConnectWithoutEquipmentInput[]
    createMany?: BorrowCreateManyEquipmentInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<BorrowCreateWithoutEquipmentInput, BorrowUncheckedCreateWithoutEquipmentInput> | BorrowCreateWithoutEquipmentInput[] | BorrowUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutEquipmentInput | BorrowCreateOrConnectWithoutEquipmentInput[]
    createMany?: BorrowCreateManyEquipmentInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type EnumEquipmentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentCategory
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EquipmentUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EquipmentUpdateeditHistoryInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type EquipmentUpdatemaintenanceLogInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type BorrowUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<BorrowCreateWithoutEquipmentInput, BorrowUncheckedCreateWithoutEquipmentInput> | BorrowCreateWithoutEquipmentInput[] | BorrowUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutEquipmentInput | BorrowCreateOrConnectWithoutEquipmentInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutEquipmentInput | BorrowUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: BorrowCreateManyEquipmentInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutEquipmentInput | BorrowUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutEquipmentInput | BorrowUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<BorrowCreateWithoutEquipmentInput, BorrowUncheckedCreateWithoutEquipmentInput> | BorrowCreateWithoutEquipmentInput[] | BorrowUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutEquipmentInput | BorrowCreateOrConnectWithoutEquipmentInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutEquipmentInput | BorrowUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: BorrowCreateManyEquipmentInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutEquipmentInput | BorrowUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutEquipmentInput | BorrowUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClassesTaughtInput = {
    create?: XOR<UserCreateWithoutClassesTaughtInput, UserUncheckedCreateWithoutClassesTaughtInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassesTaughtInput
    connect?: UserWhereUniqueInput
  }

  export type UserClassEnrollmentCreateNestedManyWithoutClassInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutClassInput, UserClassEnrollmentUncheckedCreateWithoutClassInput> | UserClassEnrollmentCreateWithoutClassInput[] | UserClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutClassInput | UserClassEnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: UserClassEnrollmentCreateManyClassInputEnvelope
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
  }

  export type BorrowCreateNestedManyWithoutClassInput = {
    create?: XOR<BorrowCreateWithoutClassInput, BorrowUncheckedCreateWithoutClassInput> | BorrowCreateWithoutClassInput[] | BorrowUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutClassInput | BorrowCreateOrConnectWithoutClassInput[]
    createMany?: BorrowCreateManyClassInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type UserClassEnrollmentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutClassInput, UserClassEnrollmentUncheckedCreateWithoutClassInput> | UserClassEnrollmentCreateWithoutClassInput[] | UserClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutClassInput | UserClassEnrollmentCreateOrConnectWithoutClassInput[]
    createMany?: UserClassEnrollmentCreateManyClassInputEnvelope
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
  }

  export type BorrowUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<BorrowCreateWithoutClassInput, BorrowUncheckedCreateWithoutClassInput> | BorrowCreateWithoutClassInput[] | BorrowUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutClassInput | BorrowCreateOrConnectWithoutClassInput[]
    createMany?: BorrowCreateManyClassInputEnvelope
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutClassesTaughtNestedInput = {
    create?: XOR<UserCreateWithoutClassesTaughtInput, UserUncheckedCreateWithoutClassesTaughtInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassesTaughtInput
    upsert?: UserUpsertWithoutClassesTaughtInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassesTaughtInput, UserUpdateWithoutClassesTaughtInput>, UserUncheckedUpdateWithoutClassesTaughtInput>
  }

  export type UserClassEnrollmentUpdateManyWithoutClassNestedInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutClassInput, UserClassEnrollmentUncheckedCreateWithoutClassInput> | UserClassEnrollmentCreateWithoutClassInput[] | UserClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutClassInput | UserClassEnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: UserClassEnrollmentUpsertWithWhereUniqueWithoutClassInput | UserClassEnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: UserClassEnrollmentCreateManyClassInputEnvelope
    set?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    disconnect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    delete?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    update?: UserClassEnrollmentUpdateWithWhereUniqueWithoutClassInput | UserClassEnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: UserClassEnrollmentUpdateManyWithWhereWithoutClassInput | UserClassEnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: UserClassEnrollmentScalarWhereInput | UserClassEnrollmentScalarWhereInput[]
  }

  export type BorrowUpdateManyWithoutClassNestedInput = {
    create?: XOR<BorrowCreateWithoutClassInput, BorrowUncheckedCreateWithoutClassInput> | BorrowCreateWithoutClassInput[] | BorrowUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutClassInput | BorrowCreateOrConnectWithoutClassInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutClassInput | BorrowUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: BorrowCreateManyClassInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutClassInput | BorrowUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutClassInput | BorrowUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type UserClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<UserClassEnrollmentCreateWithoutClassInput, UserClassEnrollmentUncheckedCreateWithoutClassInput> | UserClassEnrollmentCreateWithoutClassInput[] | UserClassEnrollmentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: UserClassEnrollmentCreateOrConnectWithoutClassInput | UserClassEnrollmentCreateOrConnectWithoutClassInput[]
    upsert?: UserClassEnrollmentUpsertWithWhereUniqueWithoutClassInput | UserClassEnrollmentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: UserClassEnrollmentCreateManyClassInputEnvelope
    set?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    disconnect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    delete?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    connect?: UserClassEnrollmentWhereUniqueInput | UserClassEnrollmentWhereUniqueInput[]
    update?: UserClassEnrollmentUpdateWithWhereUniqueWithoutClassInput | UserClassEnrollmentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: UserClassEnrollmentUpdateManyWithWhereWithoutClassInput | UserClassEnrollmentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: UserClassEnrollmentScalarWhereInput | UserClassEnrollmentScalarWhereInput[]
  }

  export type BorrowUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<BorrowCreateWithoutClassInput, BorrowUncheckedCreateWithoutClassInput> | BorrowCreateWithoutClassInput[] | BorrowUncheckedCreateWithoutClassInput[]
    connectOrCreate?: BorrowCreateOrConnectWithoutClassInput | BorrowCreateOrConnectWithoutClassInput[]
    upsert?: BorrowUpsertWithWhereUniqueWithoutClassInput | BorrowUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: BorrowCreateManyClassInputEnvelope
    set?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    disconnect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    delete?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    connect?: BorrowWhereUniqueInput | BorrowWhereUniqueInput[]
    update?: BorrowUpdateWithWhereUniqueWithoutClassInput | BorrowUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: BorrowUpdateManyWithWhereWithoutClassInput | BorrowUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClassesEnrolledInput = {
    create?: XOR<UserCreateWithoutClassesEnrolledInput, UserUncheckedCreateWithoutClassesEnrolledInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassesEnrolledInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEnrollmentsInput
    connect?: ClassWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutClassesEnrolledNestedInput = {
    create?: XOR<UserCreateWithoutClassesEnrolledInput, UserUncheckedCreateWithoutClassesEnrolledInput>
    connectOrCreate?: UserCreateOrConnectWithoutClassesEnrolledInput
    upsert?: UserUpsertWithoutClassesEnrolledInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClassesEnrolledInput, UserUpdateWithoutClassesEnrolledInput>, UserUncheckedUpdateWithoutClassesEnrolledInput>
  }

  export type ClassUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutEnrollmentsInput
    upsert?: ClassUpsertWithoutEnrollmentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutEnrollmentsInput, ClassUpdateWithoutEnrollmentsInput>, ClassUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type BorrowCreateeditHistoryInput = {
    set: InputJsonValue[]
  }

  export type UserCreateNestedOneWithoutBorrowsInitiatedInput = {
    create?: XOR<UserCreateWithoutBorrowsInitiatedInput, UserUncheckedCreateWithoutBorrowsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBorrowsInitiatedInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutBorrowRequestsInput = {
    create?: XOR<ClassCreateWithoutBorrowRequestsInput, ClassUncheckedCreateWithoutBorrowRequestsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBorrowRequestsInput
    connect?: ClassWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBorrowsSupervisedInput = {
    create?: XOR<UserCreateWithoutBorrowsSupervisedInput, UserUncheckedCreateWithoutBorrowsSupervisedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBorrowsSupervisedInput
    connect?: UserWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutBorrowRecordsInput = {
    create?: XOR<EquipmentCreateWithoutBorrowRecordsInput, EquipmentUncheckedCreateWithoutBorrowRecordsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutBorrowRecordsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type BorrowGroupMateCreateNestedManyWithoutBorrowInput = {
    create?: XOR<BorrowGroupMateCreateWithoutBorrowInput, BorrowGroupMateUncheckedCreateWithoutBorrowInput> | BorrowGroupMateCreateWithoutBorrowInput[] | BorrowGroupMateUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutBorrowInput | BorrowGroupMateCreateOrConnectWithoutBorrowInput[]
    createMany?: BorrowGroupMateCreateManyBorrowInputEnvelope
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutFicApprovalsInput = {
    create?: XOR<UserCreateWithoutFicApprovalsInput, UserUncheckedCreateWithoutFicApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFicApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStaffApprovalsInput = {
    create?: XOR<UserCreateWithoutStaffApprovalsInput, UserUncheckedCreateWithoutStaffApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type DeficiencyCreateNestedManyWithoutBorrowInput = {
    create?: XOR<DeficiencyCreateWithoutBorrowInput, DeficiencyUncheckedCreateWithoutBorrowInput> | DeficiencyCreateWithoutBorrowInput[] | DeficiencyUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutBorrowInput | DeficiencyCreateOrConnectWithoutBorrowInput[]
    createMany?: DeficiencyCreateManyBorrowInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput = {
    create?: XOR<BorrowGroupMateCreateWithoutBorrowInput, BorrowGroupMateUncheckedCreateWithoutBorrowInput> | BorrowGroupMateCreateWithoutBorrowInput[] | BorrowGroupMateUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutBorrowInput | BorrowGroupMateCreateOrConnectWithoutBorrowInput[]
    createMany?: BorrowGroupMateCreateManyBorrowInputEnvelope
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
  }

  export type DeficiencyUncheckedCreateNestedManyWithoutBorrowInput = {
    create?: XOR<DeficiencyCreateWithoutBorrowInput, DeficiencyUncheckedCreateWithoutBorrowInput> | DeficiencyCreateWithoutBorrowInput[] | DeficiencyUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutBorrowInput | DeficiencyCreateOrConnectWithoutBorrowInput[]
    createMany?: DeficiencyCreateManyBorrowInputEnvelope
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
  }

  export type EnumBorrowStatusFieldUpdateOperationsInput = {
    set?: $Enums.BorrowStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type BorrowUpdateeditHistoryInput = {
    set?: InputJsonValue[]
    push?: InputJsonValue | InputJsonValue[]
  }

  export type UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput = {
    create?: XOR<UserCreateWithoutBorrowsInitiatedInput, UserUncheckedCreateWithoutBorrowsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBorrowsInitiatedInput
    upsert?: UserUpsertWithoutBorrowsInitiatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBorrowsInitiatedInput, UserUpdateWithoutBorrowsInitiatedInput>, UserUncheckedUpdateWithoutBorrowsInitiatedInput>
  }

  export type ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput = {
    create?: XOR<ClassCreateWithoutBorrowRequestsInput, ClassUncheckedCreateWithoutBorrowRequestsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutBorrowRequestsInput
    upsert?: ClassUpsertWithoutBorrowRequestsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutBorrowRequestsInput, ClassUpdateWithoutBorrowRequestsInput>, ClassUncheckedUpdateWithoutBorrowRequestsInput>
  }

  export type UserUpdateOneWithoutBorrowsSupervisedNestedInput = {
    create?: XOR<UserCreateWithoutBorrowsSupervisedInput, UserUncheckedCreateWithoutBorrowsSupervisedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBorrowsSupervisedInput
    upsert?: UserUpsertWithoutBorrowsSupervisedInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBorrowsSupervisedInput, UserUpdateWithoutBorrowsSupervisedInput>, UserUncheckedUpdateWithoutBorrowsSupervisedInput>
  }

  export type EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput = {
    create?: XOR<EquipmentCreateWithoutBorrowRecordsInput, EquipmentUncheckedCreateWithoutBorrowRecordsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutBorrowRecordsInput
    upsert?: EquipmentUpsertWithoutBorrowRecordsInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutBorrowRecordsInput, EquipmentUpdateWithoutBorrowRecordsInput>, EquipmentUncheckedUpdateWithoutBorrowRecordsInput>
  }

  export type BorrowGroupMateUpdateManyWithoutBorrowNestedInput = {
    create?: XOR<BorrowGroupMateCreateWithoutBorrowInput, BorrowGroupMateUncheckedCreateWithoutBorrowInput> | BorrowGroupMateCreateWithoutBorrowInput[] | BorrowGroupMateUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutBorrowInput | BorrowGroupMateCreateOrConnectWithoutBorrowInput[]
    upsert?: BorrowGroupMateUpsertWithWhereUniqueWithoutBorrowInput | BorrowGroupMateUpsertWithWhereUniqueWithoutBorrowInput[]
    createMany?: BorrowGroupMateCreateManyBorrowInputEnvelope
    set?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    disconnect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    delete?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    update?: BorrowGroupMateUpdateWithWhereUniqueWithoutBorrowInput | BorrowGroupMateUpdateWithWhereUniqueWithoutBorrowInput[]
    updateMany?: BorrowGroupMateUpdateManyWithWhereWithoutBorrowInput | BorrowGroupMateUpdateManyWithWhereWithoutBorrowInput[]
    deleteMany?: BorrowGroupMateScalarWhereInput | BorrowGroupMateScalarWhereInput[]
  }

  export type UserUpdateOneWithoutFicApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutFicApprovalsInput, UserUncheckedCreateWithoutFicApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFicApprovalsInput
    upsert?: UserUpsertWithoutFicApprovalsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFicApprovalsInput, UserUpdateWithoutFicApprovalsInput>, UserUncheckedUpdateWithoutFicApprovalsInput>
  }

  export type UserUpdateOneWithoutStaffApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutStaffApprovalsInput, UserUncheckedCreateWithoutStaffApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffApprovalsInput
    upsert?: UserUpsertWithoutStaffApprovalsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffApprovalsInput, UserUpdateWithoutStaffApprovalsInput>, UserUncheckedUpdateWithoutStaffApprovalsInput>
  }

  export type DeficiencyUpdateManyWithoutBorrowNestedInput = {
    create?: XOR<DeficiencyCreateWithoutBorrowInput, DeficiencyUncheckedCreateWithoutBorrowInput> | DeficiencyCreateWithoutBorrowInput[] | DeficiencyUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutBorrowInput | DeficiencyCreateOrConnectWithoutBorrowInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutBorrowInput | DeficiencyUpsertWithWhereUniqueWithoutBorrowInput[]
    createMany?: DeficiencyCreateManyBorrowInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutBorrowInput | DeficiencyUpdateWithWhereUniqueWithoutBorrowInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutBorrowInput | DeficiencyUpdateManyWithWhereWithoutBorrowInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput = {
    create?: XOR<BorrowGroupMateCreateWithoutBorrowInput, BorrowGroupMateUncheckedCreateWithoutBorrowInput> | BorrowGroupMateCreateWithoutBorrowInput[] | BorrowGroupMateUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: BorrowGroupMateCreateOrConnectWithoutBorrowInput | BorrowGroupMateCreateOrConnectWithoutBorrowInput[]
    upsert?: BorrowGroupMateUpsertWithWhereUniqueWithoutBorrowInput | BorrowGroupMateUpsertWithWhereUniqueWithoutBorrowInput[]
    createMany?: BorrowGroupMateCreateManyBorrowInputEnvelope
    set?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    disconnect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    delete?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    connect?: BorrowGroupMateWhereUniqueInput | BorrowGroupMateWhereUniqueInput[]
    update?: BorrowGroupMateUpdateWithWhereUniqueWithoutBorrowInput | BorrowGroupMateUpdateWithWhereUniqueWithoutBorrowInput[]
    updateMany?: BorrowGroupMateUpdateManyWithWhereWithoutBorrowInput | BorrowGroupMateUpdateManyWithWhereWithoutBorrowInput[]
    deleteMany?: BorrowGroupMateScalarWhereInput | BorrowGroupMateScalarWhereInput[]
  }

  export type DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput = {
    create?: XOR<DeficiencyCreateWithoutBorrowInput, DeficiencyUncheckedCreateWithoutBorrowInput> | DeficiencyCreateWithoutBorrowInput[] | DeficiencyUncheckedCreateWithoutBorrowInput[]
    connectOrCreate?: DeficiencyCreateOrConnectWithoutBorrowInput | DeficiencyCreateOrConnectWithoutBorrowInput[]
    upsert?: DeficiencyUpsertWithWhereUniqueWithoutBorrowInput | DeficiencyUpsertWithWhereUniqueWithoutBorrowInput[]
    createMany?: DeficiencyCreateManyBorrowInputEnvelope
    set?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    disconnect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    delete?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    connect?: DeficiencyWhereUniqueInput | DeficiencyWhereUniqueInput[]
    update?: DeficiencyUpdateWithWhereUniqueWithoutBorrowInput | DeficiencyUpdateWithWhereUniqueWithoutBorrowInput[]
    updateMany?: DeficiencyUpdateManyWithWhereWithoutBorrowInput | DeficiencyUpdateManyWithWhereWithoutBorrowInput[]
    deleteMany?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
  }

  export type BorrowCreateNestedOneWithoutGroupMatesInput = {
    create?: XOR<BorrowCreateWithoutGroupMatesInput, BorrowUncheckedCreateWithoutGroupMatesInput>
    connectOrCreate?: BorrowCreateOrConnectWithoutGroupMatesInput
    connect?: BorrowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGroupBorrowMembershipInput = {
    create?: XOR<UserCreateWithoutGroupBorrowMembershipInput, UserUncheckedCreateWithoutGroupBorrowMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupBorrowMembershipInput
    connect?: UserWhereUniqueInput
  }

  export type BorrowUpdateOneRequiredWithoutGroupMatesNestedInput = {
    create?: XOR<BorrowCreateWithoutGroupMatesInput, BorrowUncheckedCreateWithoutGroupMatesInput>
    connectOrCreate?: BorrowCreateOrConnectWithoutGroupMatesInput
    upsert?: BorrowUpsertWithoutGroupMatesInput
    connect?: BorrowWhereUniqueInput
    update?: XOR<XOR<BorrowUpdateToOneWithWhereWithoutGroupMatesInput, BorrowUpdateWithoutGroupMatesInput>, BorrowUncheckedUpdateWithoutGroupMatesInput>
  }

  export type UserUpdateOneRequiredWithoutGroupBorrowMembershipNestedInput = {
    create?: XOR<UserCreateWithoutGroupBorrowMembershipInput, UserUncheckedCreateWithoutGroupBorrowMembershipInput>
    connectOrCreate?: UserCreateOrConnectWithoutGroupBorrowMembershipInput
    upsert?: UserUpsertWithoutGroupBorrowMembershipInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGroupBorrowMembershipInput, UserUpdateWithoutGroupBorrowMembershipInput>, UserUncheckedUpdateWithoutGroupBorrowMembershipInput>
  }

  export type BorrowCreateNestedOneWithoutDeficienciesInput = {
    create?: XOR<BorrowCreateWithoutDeficienciesInput, BorrowUncheckedCreateWithoutDeficienciesInput>
    connectOrCreate?: BorrowCreateOrConnectWithoutDeficienciesInput
    connect?: BorrowWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserDeficienciesInput = {
    create?: XOR<UserCreateWithoutUserDeficienciesInput, UserUncheckedCreateWithoutUserDeficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDeficienciesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTaggedDeficienciesInput = {
    create?: XOR<UserCreateWithoutTaggedDeficienciesInput, UserUncheckedCreateWithoutTaggedDeficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaggedDeficienciesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotifiedFicDeficienciesInput = {
    create?: XOR<UserCreateWithoutNotifiedFicDeficienciesInput, UserUncheckedCreateWithoutNotifiedFicDeficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotifiedFicDeficienciesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDeficiencyTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeficiencyType
  }

  export type EnumDeficiencyStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeficiencyStatus
  }

  export type BorrowUpdateOneRequiredWithoutDeficienciesNestedInput = {
    create?: XOR<BorrowCreateWithoutDeficienciesInput, BorrowUncheckedCreateWithoutDeficienciesInput>
    connectOrCreate?: BorrowCreateOrConnectWithoutDeficienciesInput
    upsert?: BorrowUpsertWithoutDeficienciesInput
    connect?: BorrowWhereUniqueInput
    update?: XOR<XOR<BorrowUpdateToOneWithWhereWithoutDeficienciesInput, BorrowUpdateWithoutDeficienciesInput>, BorrowUncheckedUpdateWithoutDeficienciesInput>
  }

  export type UserUpdateOneRequiredWithoutUserDeficienciesNestedInput = {
    create?: XOR<UserCreateWithoutUserDeficienciesInput, UserUncheckedCreateWithoutUserDeficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDeficienciesInput
    upsert?: UserUpsertWithoutUserDeficienciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserDeficienciesInput, UserUpdateWithoutUserDeficienciesInput>, UserUncheckedUpdateWithoutUserDeficienciesInput>
  }

  export type UserUpdateOneRequiredWithoutTaggedDeficienciesNestedInput = {
    create?: XOR<UserCreateWithoutTaggedDeficienciesInput, UserUncheckedCreateWithoutTaggedDeficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaggedDeficienciesInput
    upsert?: UserUpsertWithoutTaggedDeficienciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaggedDeficienciesInput, UserUpdateWithoutTaggedDeficienciesInput>, UserUncheckedUpdateWithoutTaggedDeficienciesInput>
  }

  export type UserUpdateOneWithoutNotifiedFicDeficienciesNestedInput = {
    create?: XOR<UserCreateWithoutNotifiedFicDeficienciesInput, UserUncheckedCreateWithoutNotifiedFicDeficienciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotifiedFicDeficienciesInput
    upsert?: UserUpsertWithoutNotifiedFicDeficienciesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotifiedFicDeficienciesInput, UserUpdateWithoutNotifiedFicDeficienciesInput>, UserUncheckedUpdateWithoutNotifiedFicDeficienciesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCategory | EnumEquipmentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentCategoryFilter<$PrismaModel> | $Enums.EquipmentCategory
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumEquipmentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentCategory | EnumEquipmentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentCategory[] | ListEnumEquipmentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentCategoryFilter<$PrismaModel>
    _max?: NestedEnumEquipmentCategoryFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumBorrowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBorrowStatusFilter<$PrismaModel> | $Enums.BorrowStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumBorrowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BorrowStatus | EnumBorrowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BorrowStatus[] | ListEnumBorrowStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBorrowStatusWithAggregatesFilter<$PrismaModel> | $Enums.BorrowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBorrowStatusFilter<$PrismaModel>
    _max?: NestedEnumBorrowStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumDeficiencyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyType | EnumDeficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyTypeFilter<$PrismaModel> | $Enums.DeficiencyType
  }

  export type NestedEnumDeficiencyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyStatus | EnumDeficiencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyStatusFilter<$PrismaModel> | $Enums.DeficiencyStatus
  }

  export type NestedEnumDeficiencyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyType | EnumDeficiencyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyType[] | ListEnumDeficiencyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeficiencyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeficiencyTypeFilter<$PrismaModel>
    _max?: NestedEnumDeficiencyTypeFilter<$PrismaModel>
  }

  export type NestedEnumDeficiencyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeficiencyStatus | EnumDeficiencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeficiencyStatus[] | ListEnumDeficiencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeficiencyStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeficiencyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeficiencyStatusFilter<$PrismaModel>
    _max?: NestedEnumDeficiencyStatusFilter<$PrismaModel>
  }

  export type ClassCreateWithoutFicInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: UserClassEnrollmentCreateNestedManyWithoutClassInput
    borrowRequests?: BorrowCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutFicInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: UserClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
    borrowRequests?: BorrowUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutFicInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutFicInput, ClassUncheckedCreateWithoutFicInput>
  }

  export type ClassCreateManyFicInputEnvelope = {
    data: ClassCreateManyFicInput | ClassCreateManyFicInput[]
  }

  export type UserClassEnrollmentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    class: ClassCreateNestedOneWithoutEnrollmentsInput
  }

  export type UserClassEnrollmentUncheckedCreateWithoutUserInput = {
    id?: string
    classId: string
    createdAt?: Date | string
  }

  export type UserClassEnrollmentCreateOrConnectWithoutUserInput = {
    where: UserClassEnrollmentWhereUniqueInput
    create: XOR<UserClassEnrollmentCreateWithoutUserInput, UserClassEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type UserClassEnrollmentCreateManyUserInputEnvelope = {
    data: UserClassEnrollmentCreateManyUserInput | UserClassEnrollmentCreateManyUserInput[]
  }

  export type BorrowCreateWithoutBorrowerInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutBorrowerInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutBorrowerInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutBorrowerInput, BorrowUncheckedCreateWithoutBorrowerInput>
  }

  export type BorrowCreateManyBorrowerInputEnvelope = {
    data: BorrowCreateManyBorrowerInput | BorrowCreateManyBorrowerInput[]
  }

  export type BorrowCreateWithoutFicInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutFicInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutFicInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutFicInput, BorrowUncheckedCreateWithoutFicInput>
  }

  export type BorrowCreateManyFicInputEnvelope = {
    data: BorrowCreateManyFicInput | BorrowCreateManyFicInput[]
  }

  export type BorrowCreateWithoutApprovedByFicInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutApprovedByFicInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutApprovedByFicInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutApprovedByFicInput, BorrowUncheckedCreateWithoutApprovedByFicInput>
  }

  export type BorrowCreateManyApprovedByFicInputEnvelope = {
    data: BorrowCreateManyApprovedByFicInput | BorrowCreateManyApprovedByFicInput[]
  }

  export type BorrowCreateWithoutApprovedByStaffInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutApprovedByStaffInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutApprovedByStaffInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutApprovedByStaffInput, BorrowUncheckedCreateWithoutApprovedByStaffInput>
  }

  export type BorrowCreateManyApprovedByStaffInputEnvelope = {
    data: BorrowCreateManyApprovedByStaffInput | BorrowCreateManyApprovedByStaffInput[]
  }

  export type BorrowGroupMateCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    borrow: BorrowCreateNestedOneWithoutGroupMatesInput
  }

  export type BorrowGroupMateUncheckedCreateWithoutUserInput = {
    id?: string
    borrowId: string
    createdAt?: Date | string
  }

  export type BorrowGroupMateCreateOrConnectWithoutUserInput = {
    where: BorrowGroupMateWhereUniqueInput
    create: XOR<BorrowGroupMateCreateWithoutUserInput, BorrowGroupMateUncheckedCreateWithoutUserInput>
  }

  export type BorrowGroupMateCreateManyUserInputEnvelope = {
    data: BorrowGroupMateCreateManyUserInput | BorrowGroupMateCreateManyUserInput[]
  }

  export type DeficiencyCreateWithoutUserInput = {
    id?: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    borrow: BorrowCreateNestedOneWithoutDeficienciesInput
    taggedBy: UserCreateNestedOneWithoutTaggedDeficienciesInput
    ficToNotify?: UserCreateNestedOneWithoutNotifiedFicDeficienciesInput
  }

  export type DeficiencyUncheckedCreateWithoutUserInput = {
    id?: string
    borrowId: string
    taggedById: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyCreateOrConnectWithoutUserInput = {
    where: DeficiencyWhereUniqueInput
    create: XOR<DeficiencyCreateWithoutUserInput, DeficiencyUncheckedCreateWithoutUserInput>
  }

  export type DeficiencyCreateManyUserInputEnvelope = {
    data: DeficiencyCreateManyUserInput | DeficiencyCreateManyUserInput[]
  }

  export type DeficiencyCreateWithoutTaggedByInput = {
    id?: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    borrow: BorrowCreateNestedOneWithoutDeficienciesInput
    user: UserCreateNestedOneWithoutUserDeficienciesInput
    ficToNotify?: UserCreateNestedOneWithoutNotifiedFicDeficienciesInput
  }

  export type DeficiencyUncheckedCreateWithoutTaggedByInput = {
    id?: string
    borrowId: string
    userId: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyCreateOrConnectWithoutTaggedByInput = {
    where: DeficiencyWhereUniqueInput
    create: XOR<DeficiencyCreateWithoutTaggedByInput, DeficiencyUncheckedCreateWithoutTaggedByInput>
  }

  export type DeficiencyCreateManyTaggedByInputEnvelope = {
    data: DeficiencyCreateManyTaggedByInput | DeficiencyCreateManyTaggedByInput[]
  }

  export type DeficiencyCreateWithoutFicToNotifyInput = {
    id?: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    borrow: BorrowCreateNestedOneWithoutDeficienciesInput
    user: UserCreateNestedOneWithoutUserDeficienciesInput
    taggedBy: UserCreateNestedOneWithoutTaggedDeficienciesInput
  }

  export type DeficiencyUncheckedCreateWithoutFicToNotifyInput = {
    id?: string
    borrowId: string
    userId: string
    taggedById: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyCreateOrConnectWithoutFicToNotifyInput = {
    where: DeficiencyWhereUniqueInput
    create: XOR<DeficiencyCreateWithoutFicToNotifyInput, DeficiencyUncheckedCreateWithoutFicToNotifyInput>
  }

  export type DeficiencyCreateManyFicToNotifyInputEnvelope = {
    data: DeficiencyCreateManyFicToNotifyInput | DeficiencyCreateManyFicToNotifyInput[]
  }

  export type ClassUpsertWithWhereUniqueWithoutFicInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutFicInput, ClassUncheckedUpdateWithoutFicInput>
    create: XOR<ClassCreateWithoutFicInput, ClassUncheckedCreateWithoutFicInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutFicInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutFicInput, ClassUncheckedUpdateWithoutFicInput>
  }

  export type ClassUpdateManyWithWhereWithoutFicInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutFicInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: StringFilter<"Class"> | string
    courseCode?: StringFilter<"Class"> | string
    section?: StringFilter<"Class"> | string
    semester?: StringFilter<"Class"> | string
    isActive?: BoolFilter<"Class"> | boolean
    ficId?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
  }

  export type UserClassEnrollmentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserClassEnrollmentWhereUniqueInput
    update: XOR<UserClassEnrollmentUpdateWithoutUserInput, UserClassEnrollmentUncheckedUpdateWithoutUserInput>
    create: XOR<UserClassEnrollmentCreateWithoutUserInput, UserClassEnrollmentUncheckedCreateWithoutUserInput>
  }

  export type UserClassEnrollmentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserClassEnrollmentWhereUniqueInput
    data: XOR<UserClassEnrollmentUpdateWithoutUserInput, UserClassEnrollmentUncheckedUpdateWithoutUserInput>
  }

  export type UserClassEnrollmentUpdateManyWithWhereWithoutUserInput = {
    where: UserClassEnrollmentScalarWhereInput
    data: XOR<UserClassEnrollmentUpdateManyMutationInput, UserClassEnrollmentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserClassEnrollmentScalarWhereInput = {
    AND?: UserClassEnrollmentScalarWhereInput | UserClassEnrollmentScalarWhereInput[]
    OR?: UserClassEnrollmentScalarWhereInput[]
    NOT?: UserClassEnrollmentScalarWhereInput | UserClassEnrollmentScalarWhereInput[]
    id?: StringFilter<"UserClassEnrollment"> | string
    userId?: StringFilter<"UserClassEnrollment"> | string
    classId?: StringFilter<"UserClassEnrollment"> | string
    createdAt?: DateTimeFilter<"UserClassEnrollment"> | Date | string
  }

  export type BorrowUpsertWithWhereUniqueWithoutBorrowerInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutBorrowerInput, BorrowUncheckedUpdateWithoutBorrowerInput>
    create: XOR<BorrowCreateWithoutBorrowerInput, BorrowUncheckedCreateWithoutBorrowerInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutBorrowerInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutBorrowerInput, BorrowUncheckedUpdateWithoutBorrowerInput>
  }

  export type BorrowUpdateManyWithWhereWithoutBorrowerInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutBorrowerInput>
  }

  export type BorrowScalarWhereInput = {
    AND?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
    OR?: BorrowScalarWhereInput[]
    NOT?: BorrowScalarWhereInput | BorrowScalarWhereInput[]
    id?: StringFilter<"Borrow"> | string
    requestSubmissionTime?: DateTimeFilter<"Borrow"> | Date | string
    requestedStartDate?: DateTimeFilter<"Borrow"> | Date | string
    borrowerId?: StringFilter<"Borrow"> | string
    classId?: StringFilter<"Borrow"> | string
    ficId?: StringNullableFilter<"Borrow"> | string | null
    equipmentId?: StringFilter<"Borrow"> | string
    borrowStatus?: EnumBorrowStatusFilter<"Borrow"> | $Enums.BorrowStatus
    approvedByFicId?: StringNullableFilter<"Borrow"> | string | null
    approvedByStaffId?: StringNullableFilter<"Borrow"> | string | null
    checkoutTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    expectedReturnTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    actualReturnTime?: DateTimeNullableFilter<"Borrow"> | Date | string | null
    returnCondition?: StringNullableFilter<"Borrow"> | string | null
    returnRemarks?: StringNullableFilter<"Borrow"> | string | null
    editHistory?: JsonNullableListFilter<"Borrow">
    createdAt?: DateTimeFilter<"Borrow"> | Date | string
    updatedAt?: DateTimeFilter<"Borrow"> | Date | string
  }

  export type BorrowUpsertWithWhereUniqueWithoutFicInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutFicInput, BorrowUncheckedUpdateWithoutFicInput>
    create: XOR<BorrowCreateWithoutFicInput, BorrowUncheckedCreateWithoutFicInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutFicInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutFicInput, BorrowUncheckedUpdateWithoutFicInput>
  }

  export type BorrowUpdateManyWithWhereWithoutFicInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutFicInput>
  }

  export type BorrowUpsertWithWhereUniqueWithoutApprovedByFicInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutApprovedByFicInput, BorrowUncheckedUpdateWithoutApprovedByFicInput>
    create: XOR<BorrowCreateWithoutApprovedByFicInput, BorrowUncheckedCreateWithoutApprovedByFicInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutApprovedByFicInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutApprovedByFicInput, BorrowUncheckedUpdateWithoutApprovedByFicInput>
  }

  export type BorrowUpdateManyWithWhereWithoutApprovedByFicInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutApprovedByFicInput>
  }

  export type BorrowUpsertWithWhereUniqueWithoutApprovedByStaffInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutApprovedByStaffInput, BorrowUncheckedUpdateWithoutApprovedByStaffInput>
    create: XOR<BorrowCreateWithoutApprovedByStaffInput, BorrowUncheckedCreateWithoutApprovedByStaffInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutApprovedByStaffInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutApprovedByStaffInput, BorrowUncheckedUpdateWithoutApprovedByStaffInput>
  }

  export type BorrowUpdateManyWithWhereWithoutApprovedByStaffInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutApprovedByStaffInput>
  }

  export type BorrowGroupMateUpsertWithWhereUniqueWithoutUserInput = {
    where: BorrowGroupMateWhereUniqueInput
    update: XOR<BorrowGroupMateUpdateWithoutUserInput, BorrowGroupMateUncheckedUpdateWithoutUserInput>
    create: XOR<BorrowGroupMateCreateWithoutUserInput, BorrowGroupMateUncheckedCreateWithoutUserInput>
  }

  export type BorrowGroupMateUpdateWithWhereUniqueWithoutUserInput = {
    where: BorrowGroupMateWhereUniqueInput
    data: XOR<BorrowGroupMateUpdateWithoutUserInput, BorrowGroupMateUncheckedUpdateWithoutUserInput>
  }

  export type BorrowGroupMateUpdateManyWithWhereWithoutUserInput = {
    where: BorrowGroupMateScalarWhereInput
    data: XOR<BorrowGroupMateUpdateManyMutationInput, BorrowGroupMateUncheckedUpdateManyWithoutUserInput>
  }

  export type BorrowGroupMateScalarWhereInput = {
    AND?: BorrowGroupMateScalarWhereInput | BorrowGroupMateScalarWhereInput[]
    OR?: BorrowGroupMateScalarWhereInput[]
    NOT?: BorrowGroupMateScalarWhereInput | BorrowGroupMateScalarWhereInput[]
    id?: StringFilter<"BorrowGroupMate"> | string
    borrowId?: StringFilter<"BorrowGroupMate"> | string
    userId?: StringFilter<"BorrowGroupMate"> | string
    createdAt?: DateTimeFilter<"BorrowGroupMate"> | Date | string
  }

  export type DeficiencyUpsertWithWhereUniqueWithoutUserInput = {
    where: DeficiencyWhereUniqueInput
    update: XOR<DeficiencyUpdateWithoutUserInput, DeficiencyUncheckedUpdateWithoutUserInput>
    create: XOR<DeficiencyCreateWithoutUserInput, DeficiencyUncheckedCreateWithoutUserInput>
  }

  export type DeficiencyUpdateWithWhereUniqueWithoutUserInput = {
    where: DeficiencyWhereUniqueInput
    data: XOR<DeficiencyUpdateWithoutUserInput, DeficiencyUncheckedUpdateWithoutUserInput>
  }

  export type DeficiencyUpdateManyWithWhereWithoutUserInput = {
    where: DeficiencyScalarWhereInput
    data: XOR<DeficiencyUpdateManyMutationInput, DeficiencyUncheckedUpdateManyWithoutUserInput>
  }

  export type DeficiencyScalarWhereInput = {
    AND?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
    OR?: DeficiencyScalarWhereInput[]
    NOT?: DeficiencyScalarWhereInput | DeficiencyScalarWhereInput[]
    id?: StringFilter<"Deficiency"> | string
    borrowId?: StringFilter<"Deficiency"> | string
    userId?: StringFilter<"Deficiency"> | string
    taggedById?: StringFilter<"Deficiency"> | string
    ficToNotifyId?: StringNullableFilter<"Deficiency"> | string | null
    type?: EnumDeficiencyTypeFilter<"Deficiency"> | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFilter<"Deficiency"> | $Enums.DeficiencyStatus
    description?: StringNullableFilter<"Deficiency"> | string | null
    resolution?: StringNullableFilter<"Deficiency"> | string | null
    createdAt?: DateTimeFilter<"Deficiency"> | Date | string
    updatedAt?: DateTimeFilter<"Deficiency"> | Date | string
  }

  export type DeficiencyUpsertWithWhereUniqueWithoutTaggedByInput = {
    where: DeficiencyWhereUniqueInput
    update: XOR<DeficiencyUpdateWithoutTaggedByInput, DeficiencyUncheckedUpdateWithoutTaggedByInput>
    create: XOR<DeficiencyCreateWithoutTaggedByInput, DeficiencyUncheckedCreateWithoutTaggedByInput>
  }

  export type DeficiencyUpdateWithWhereUniqueWithoutTaggedByInput = {
    where: DeficiencyWhereUniqueInput
    data: XOR<DeficiencyUpdateWithoutTaggedByInput, DeficiencyUncheckedUpdateWithoutTaggedByInput>
  }

  export type DeficiencyUpdateManyWithWhereWithoutTaggedByInput = {
    where: DeficiencyScalarWhereInput
    data: XOR<DeficiencyUpdateManyMutationInput, DeficiencyUncheckedUpdateManyWithoutTaggedByInput>
  }

  export type DeficiencyUpsertWithWhereUniqueWithoutFicToNotifyInput = {
    where: DeficiencyWhereUniqueInput
    update: XOR<DeficiencyUpdateWithoutFicToNotifyInput, DeficiencyUncheckedUpdateWithoutFicToNotifyInput>
    create: XOR<DeficiencyCreateWithoutFicToNotifyInput, DeficiencyUncheckedCreateWithoutFicToNotifyInput>
  }

  export type DeficiencyUpdateWithWhereUniqueWithoutFicToNotifyInput = {
    where: DeficiencyWhereUniqueInput
    data: XOR<DeficiencyUpdateWithoutFicToNotifyInput, DeficiencyUncheckedUpdateWithoutFicToNotifyInput>
  }

  export type DeficiencyUpdateManyWithWhereWithoutFicToNotifyInput = {
    where: DeficiencyScalarWhereInput
    data: XOR<DeficiencyUpdateManyMutationInput, DeficiencyUncheckedUpdateManyWithoutFicToNotifyInput>
  }

  export type BorrowCreateWithoutEquipmentInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutEquipmentInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutEquipmentInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutEquipmentInput, BorrowUncheckedCreateWithoutEquipmentInput>
  }

  export type BorrowCreateManyEquipmentInputEnvelope = {
    data: BorrowCreateManyEquipmentInput | BorrowCreateManyEquipmentInput[]
  }

  export type BorrowUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutEquipmentInput, BorrowUncheckedUpdateWithoutEquipmentInput>
    create: XOR<BorrowCreateWithoutEquipmentInput, BorrowUncheckedCreateWithoutEquipmentInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutEquipmentInput, BorrowUncheckedUpdateWithoutEquipmentInput>
  }

  export type BorrowUpdateManyWithWhereWithoutEquipmentInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type UserCreateWithoutClassesTaughtInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutClassesTaughtInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutClassesTaughtInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassesTaughtInput, UserUncheckedCreateWithoutClassesTaughtInput>
  }

  export type UserClassEnrollmentCreateWithoutClassInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutClassesEnrolledInput
  }

  export type UserClassEnrollmentUncheckedCreateWithoutClassInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserClassEnrollmentCreateOrConnectWithoutClassInput = {
    where: UserClassEnrollmentWhereUniqueInput
    create: XOR<UserClassEnrollmentCreateWithoutClassInput, UserClassEnrollmentUncheckedCreateWithoutClassInput>
  }

  export type UserClassEnrollmentCreateManyClassInputEnvelope = {
    data: UserClassEnrollmentCreateManyClassInput | UserClassEnrollmentCreateManyClassInput[]
  }

  export type BorrowCreateWithoutClassInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutClassInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutClassInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutClassInput, BorrowUncheckedCreateWithoutClassInput>
  }

  export type BorrowCreateManyClassInputEnvelope = {
    data: BorrowCreateManyClassInput | BorrowCreateManyClassInput[]
  }

  export type UserUpsertWithoutClassesTaughtInput = {
    update: XOR<UserUpdateWithoutClassesTaughtInput, UserUncheckedUpdateWithoutClassesTaughtInput>
    create: XOR<UserCreateWithoutClassesTaughtInput, UserUncheckedCreateWithoutClassesTaughtInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassesTaughtInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassesTaughtInput, UserUncheckedUpdateWithoutClassesTaughtInput>
  }

  export type UserUpdateWithoutClassesTaughtInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutClassesTaughtInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserClassEnrollmentUpsertWithWhereUniqueWithoutClassInput = {
    where: UserClassEnrollmentWhereUniqueInput
    update: XOR<UserClassEnrollmentUpdateWithoutClassInput, UserClassEnrollmentUncheckedUpdateWithoutClassInput>
    create: XOR<UserClassEnrollmentCreateWithoutClassInput, UserClassEnrollmentUncheckedCreateWithoutClassInput>
  }

  export type UserClassEnrollmentUpdateWithWhereUniqueWithoutClassInput = {
    where: UserClassEnrollmentWhereUniqueInput
    data: XOR<UserClassEnrollmentUpdateWithoutClassInput, UserClassEnrollmentUncheckedUpdateWithoutClassInput>
  }

  export type UserClassEnrollmentUpdateManyWithWhereWithoutClassInput = {
    where: UserClassEnrollmentScalarWhereInput
    data: XOR<UserClassEnrollmentUpdateManyMutationInput, UserClassEnrollmentUncheckedUpdateManyWithoutClassInput>
  }

  export type BorrowUpsertWithWhereUniqueWithoutClassInput = {
    where: BorrowWhereUniqueInput
    update: XOR<BorrowUpdateWithoutClassInput, BorrowUncheckedUpdateWithoutClassInput>
    create: XOR<BorrowCreateWithoutClassInput, BorrowUncheckedCreateWithoutClassInput>
  }

  export type BorrowUpdateWithWhereUniqueWithoutClassInput = {
    where: BorrowWhereUniqueInput
    data: XOR<BorrowUpdateWithoutClassInput, BorrowUncheckedUpdateWithoutClassInput>
  }

  export type BorrowUpdateManyWithWhereWithoutClassInput = {
    where: BorrowScalarWhereInput
    data: XOR<BorrowUpdateManyMutationInput, BorrowUncheckedUpdateManyWithoutClassInput>
  }

  export type UserCreateWithoutClassesEnrolledInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutClassesEnrolledInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutClassesEnrolledInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClassesEnrolledInput, UserUncheckedCreateWithoutClassesEnrolledInput>
  }

  export type ClassCreateWithoutEnrollmentsInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fic: UserCreateNestedOneWithoutClassesTaughtInput
    borrowRequests?: BorrowCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    ficId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    borrowRequests?: BorrowUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutEnrollmentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserUpsertWithoutClassesEnrolledInput = {
    update: XOR<UserUpdateWithoutClassesEnrolledInput, UserUncheckedUpdateWithoutClassesEnrolledInput>
    create: XOR<UserCreateWithoutClassesEnrolledInput, UserUncheckedCreateWithoutClassesEnrolledInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClassesEnrolledInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClassesEnrolledInput, UserUncheckedUpdateWithoutClassesEnrolledInput>
  }

  export type UserUpdateWithoutClassesEnrolledInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutClassesEnrolledInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type ClassUpsertWithoutEnrollmentsInput = {
    update: XOR<ClassUpdateWithoutEnrollmentsInput, ClassUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<ClassCreateWithoutEnrollmentsInput, ClassUncheckedCreateWithoutEnrollmentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutEnrollmentsInput, ClassUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ClassUpdateWithoutEnrollmentsInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fic?: UserUpdateOneRequiredWithoutClassesTaughtNestedInput
    borrowRequests?: BorrowUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutEnrollmentsInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ficId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowRequests?: BorrowUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserCreateWithoutBorrowsInitiatedInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutBorrowsInitiatedInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutBorrowsInitiatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBorrowsInitiatedInput, UserUncheckedCreateWithoutBorrowsInitiatedInput>
  }

  export type ClassCreateWithoutBorrowRequestsInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fic: UserCreateNestedOneWithoutClassesTaughtInput
    enrollments?: UserClassEnrollmentCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutBorrowRequestsInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    ficId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    enrollments?: UserClassEnrollmentUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutBorrowRequestsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutBorrowRequestsInput, ClassUncheckedCreateWithoutBorrowRequestsInput>
  }

  export type UserCreateWithoutBorrowsSupervisedInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutBorrowsSupervisedInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutBorrowsSupervisedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBorrowsSupervisedInput, UserUncheckedCreateWithoutBorrowsSupervisedInput>
  }

  export type EquipmentCreateWithoutBorrowRecordsInput = {
    id?: string
    name: string
    equipmentId?: string | null
    qrCodeValue?: string
    category?: $Enums.EquipmentCategory
    condition?: string | null
    status?: $Enums.EquipmentStatus
    stockCount?: number
    purchaseCost?: number | null
    images?: EquipmentCreateimagesInput | string[]
    editHistory?: EquipmentCreateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentCreatemaintenanceLogInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentUncheckedCreateWithoutBorrowRecordsInput = {
    id?: string
    name: string
    equipmentId?: string | null
    qrCodeValue?: string
    category?: $Enums.EquipmentCategory
    condition?: string | null
    status?: $Enums.EquipmentStatus
    stockCount?: number
    purchaseCost?: number | null
    images?: EquipmentCreateimagesInput | string[]
    editHistory?: EquipmentCreateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentCreatemaintenanceLogInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateOrConnectWithoutBorrowRecordsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutBorrowRecordsInput, EquipmentUncheckedCreateWithoutBorrowRecordsInput>
  }

  export type BorrowGroupMateCreateWithoutBorrowInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutGroupBorrowMembershipInput
  }

  export type BorrowGroupMateUncheckedCreateWithoutBorrowInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BorrowGroupMateCreateOrConnectWithoutBorrowInput = {
    where: BorrowGroupMateWhereUniqueInput
    create: XOR<BorrowGroupMateCreateWithoutBorrowInput, BorrowGroupMateUncheckedCreateWithoutBorrowInput>
  }

  export type BorrowGroupMateCreateManyBorrowInputEnvelope = {
    data: BorrowGroupMateCreateManyBorrowInput | BorrowGroupMateCreateManyBorrowInput[]
  }

  export type UserCreateWithoutFicApprovalsInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutFicApprovalsInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutFicApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFicApprovalsInput, UserUncheckedCreateWithoutFicApprovalsInput>
  }

  export type UserCreateWithoutStaffApprovalsInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutStaffApprovalsInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutStaffApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffApprovalsInput, UserUncheckedCreateWithoutStaffApprovalsInput>
  }

  export type DeficiencyCreateWithoutBorrowInput = {
    id?: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserDeficienciesInput
    taggedBy: UserCreateNestedOneWithoutTaggedDeficienciesInput
    ficToNotify?: UserCreateNestedOneWithoutNotifiedFicDeficienciesInput
  }

  export type DeficiencyUncheckedCreateWithoutBorrowInput = {
    id?: string
    userId: string
    taggedById: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyCreateOrConnectWithoutBorrowInput = {
    where: DeficiencyWhereUniqueInput
    create: XOR<DeficiencyCreateWithoutBorrowInput, DeficiencyUncheckedCreateWithoutBorrowInput>
  }

  export type DeficiencyCreateManyBorrowInputEnvelope = {
    data: DeficiencyCreateManyBorrowInput | DeficiencyCreateManyBorrowInput[]
  }

  export type UserUpsertWithoutBorrowsInitiatedInput = {
    update: XOR<UserUpdateWithoutBorrowsInitiatedInput, UserUncheckedUpdateWithoutBorrowsInitiatedInput>
    create: XOR<UserCreateWithoutBorrowsInitiatedInput, UserUncheckedCreateWithoutBorrowsInitiatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBorrowsInitiatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBorrowsInitiatedInput, UserUncheckedUpdateWithoutBorrowsInitiatedInput>
  }

  export type UserUpdateWithoutBorrowsInitiatedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutBorrowsInitiatedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type ClassUpsertWithoutBorrowRequestsInput = {
    update: XOR<ClassUpdateWithoutBorrowRequestsInput, ClassUncheckedUpdateWithoutBorrowRequestsInput>
    create: XOR<ClassCreateWithoutBorrowRequestsInput, ClassUncheckedCreateWithoutBorrowRequestsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutBorrowRequestsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutBorrowRequestsInput, ClassUncheckedUpdateWithoutBorrowRequestsInput>
  }

  export type ClassUpdateWithoutBorrowRequestsInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fic?: UserUpdateOneRequiredWithoutClassesTaughtNestedInput
    enrollments?: UserClassEnrollmentUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutBorrowRequestsInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    ficId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: UserClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
  }

  export type UserUpsertWithoutBorrowsSupervisedInput = {
    update: XOR<UserUpdateWithoutBorrowsSupervisedInput, UserUncheckedUpdateWithoutBorrowsSupervisedInput>
    create: XOR<UserCreateWithoutBorrowsSupervisedInput, UserUncheckedCreateWithoutBorrowsSupervisedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBorrowsSupervisedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBorrowsSupervisedInput, UserUncheckedUpdateWithoutBorrowsSupervisedInput>
  }

  export type UserUpdateWithoutBorrowsSupervisedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutBorrowsSupervisedInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type EquipmentUpsertWithoutBorrowRecordsInput = {
    update: XOR<EquipmentUpdateWithoutBorrowRecordsInput, EquipmentUncheckedUpdateWithoutBorrowRecordsInput>
    create: XOR<EquipmentCreateWithoutBorrowRecordsInput, EquipmentUncheckedCreateWithoutBorrowRecordsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutBorrowRecordsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutBorrowRecordsInput, EquipmentUncheckedUpdateWithoutBorrowRecordsInput>
  }

  export type EquipmentUpdateWithoutBorrowRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeValue?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentCategoryFieldUpdateOperationsInput | $Enums.EquipmentCategory
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    stockCount?: IntFieldUpdateOperationsInput | number
    purchaseCost?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: EquipmentUpdateimagesInput | string[]
    editHistory?: EquipmentUpdateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentUpdatemaintenanceLogInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUncheckedUpdateWithoutBorrowRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCodeValue?: StringFieldUpdateOperationsInput | string
    category?: EnumEquipmentCategoryFieldUpdateOperationsInput | $Enums.EquipmentCategory
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    stockCount?: IntFieldUpdateOperationsInput | number
    purchaseCost?: NullableFloatFieldUpdateOperationsInput | number | null
    images?: EquipmentUpdateimagesInput | string[]
    editHistory?: EquipmentUpdateeditHistoryInput | InputJsonValue[]
    maintenanceLog?: EquipmentUpdatemaintenanceLogInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateUpsertWithWhereUniqueWithoutBorrowInput = {
    where: BorrowGroupMateWhereUniqueInput
    update: XOR<BorrowGroupMateUpdateWithoutBorrowInput, BorrowGroupMateUncheckedUpdateWithoutBorrowInput>
    create: XOR<BorrowGroupMateCreateWithoutBorrowInput, BorrowGroupMateUncheckedCreateWithoutBorrowInput>
  }

  export type BorrowGroupMateUpdateWithWhereUniqueWithoutBorrowInput = {
    where: BorrowGroupMateWhereUniqueInput
    data: XOR<BorrowGroupMateUpdateWithoutBorrowInput, BorrowGroupMateUncheckedUpdateWithoutBorrowInput>
  }

  export type BorrowGroupMateUpdateManyWithWhereWithoutBorrowInput = {
    where: BorrowGroupMateScalarWhereInput
    data: XOR<BorrowGroupMateUpdateManyMutationInput, BorrowGroupMateUncheckedUpdateManyWithoutBorrowInput>
  }

  export type UserUpsertWithoutFicApprovalsInput = {
    update: XOR<UserUpdateWithoutFicApprovalsInput, UserUncheckedUpdateWithoutFicApprovalsInput>
    create: XOR<UserCreateWithoutFicApprovalsInput, UserUncheckedCreateWithoutFicApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFicApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFicApprovalsInput, UserUncheckedUpdateWithoutFicApprovalsInput>
  }

  export type UserUpdateWithoutFicApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutFicApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUpsertWithoutStaffApprovalsInput = {
    update: XOR<UserUpdateWithoutStaffApprovalsInput, UserUncheckedUpdateWithoutStaffApprovalsInput>
    create: XOR<UserCreateWithoutStaffApprovalsInput, UserUncheckedCreateWithoutStaffApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffApprovalsInput, UserUncheckedUpdateWithoutStaffApprovalsInput>
  }

  export type UserUpdateWithoutStaffApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffApprovalsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type DeficiencyUpsertWithWhereUniqueWithoutBorrowInput = {
    where: DeficiencyWhereUniqueInput
    update: XOR<DeficiencyUpdateWithoutBorrowInput, DeficiencyUncheckedUpdateWithoutBorrowInput>
    create: XOR<DeficiencyCreateWithoutBorrowInput, DeficiencyUncheckedCreateWithoutBorrowInput>
  }

  export type DeficiencyUpdateWithWhereUniqueWithoutBorrowInput = {
    where: DeficiencyWhereUniqueInput
    data: XOR<DeficiencyUpdateWithoutBorrowInput, DeficiencyUncheckedUpdateWithoutBorrowInput>
  }

  export type DeficiencyUpdateManyWithWhereWithoutBorrowInput = {
    where: DeficiencyScalarWhereInput
    data: XOR<DeficiencyUpdateManyMutationInput, DeficiencyUncheckedUpdateManyWithoutBorrowInput>
  }

  export type BorrowCreateWithoutGroupMatesInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
    deficiencies?: DeficiencyCreateNestedManyWithoutBorrowInput
  }

  export type BorrowUncheckedCreateWithoutGroupMatesInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    deficiencies?: DeficiencyUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutGroupMatesInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutGroupMatesInput, BorrowUncheckedCreateWithoutGroupMatesInput>
  }

  export type UserCreateWithoutGroupBorrowMembershipInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutGroupBorrowMembershipInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutGroupBorrowMembershipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGroupBorrowMembershipInput, UserUncheckedCreateWithoutGroupBorrowMembershipInput>
  }

  export type BorrowUpsertWithoutGroupMatesInput = {
    update: XOR<BorrowUpdateWithoutGroupMatesInput, BorrowUncheckedUpdateWithoutGroupMatesInput>
    create: XOR<BorrowCreateWithoutGroupMatesInput, BorrowUncheckedCreateWithoutGroupMatesInput>
    where?: BorrowWhereInput
  }

  export type BorrowUpdateToOneWithWhereWithoutGroupMatesInput = {
    where?: BorrowWhereInput
    data: XOR<BorrowUpdateWithoutGroupMatesInput, BorrowUncheckedUpdateWithoutGroupMatesInput>
  }

  export type BorrowUpdateWithoutGroupMatesInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutGroupMatesInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type UserUpsertWithoutGroupBorrowMembershipInput = {
    update: XOR<UserUpdateWithoutGroupBorrowMembershipInput, UserUncheckedUpdateWithoutGroupBorrowMembershipInput>
    create: XOR<UserCreateWithoutGroupBorrowMembershipInput, UserUncheckedCreateWithoutGroupBorrowMembershipInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGroupBorrowMembershipInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGroupBorrowMembershipInput, UserUncheckedUpdateWithoutGroupBorrowMembershipInput>
  }

  export type UserUpdateWithoutGroupBorrowMembershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutGroupBorrowMembershipInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type BorrowCreateWithoutDeficienciesInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowStatus?: $Enums.BorrowStatus
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    borrower: UserCreateNestedOneWithoutBorrowsInitiatedInput
    class: ClassCreateNestedOneWithoutBorrowRequestsInput
    fic?: UserCreateNestedOneWithoutBorrowsSupervisedInput
    equipment: EquipmentCreateNestedOneWithoutBorrowRecordsInput
    groupMates?: BorrowGroupMateCreateNestedManyWithoutBorrowInput
    approvedByFic?: UserCreateNestedOneWithoutFicApprovalsInput
    approvedByStaff?: UserCreateNestedOneWithoutStaffApprovalsInput
  }

  export type BorrowUncheckedCreateWithoutDeficienciesInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
    groupMates?: BorrowGroupMateUncheckedCreateNestedManyWithoutBorrowInput
  }

  export type BorrowCreateOrConnectWithoutDeficienciesInput = {
    where: BorrowWhereUniqueInput
    create: XOR<BorrowCreateWithoutDeficienciesInput, BorrowUncheckedCreateWithoutDeficienciesInput>
  }

  export type UserCreateWithoutUserDeficienciesInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutUserDeficienciesInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutUserDeficienciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDeficienciesInput, UserUncheckedCreateWithoutUserDeficienciesInput>
  }

  export type UserCreateWithoutTaggedDeficienciesInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    notifiedFicDeficiencies?: DeficiencyCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserUncheckedCreateWithoutTaggedDeficienciesInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    notifiedFicDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutFicToNotifyInput
  }

  export type UserCreateOrConnectWithoutTaggedDeficienciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaggedDeficienciesInput, UserUncheckedCreateWithoutTaggedDeficienciesInput>
  }

  export type UserCreateWithoutNotifiedFicDeficienciesInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyCreateNestedManyWithoutTaggedByInput
  }

  export type UserUncheckedCreateWithoutNotifiedFicDeficienciesInput = {
    id?: string
    name: string
    email: string
    studentNumber?: string | null
    contactNumber?: string | null
    sex?: string | null
    password: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classesTaught?: ClassUncheckedCreateNestedManyWithoutFicInput
    classesEnrolled?: UserClassEnrollmentUncheckedCreateNestedManyWithoutUserInput
    borrowsInitiated?: BorrowUncheckedCreateNestedManyWithoutBorrowerInput
    borrowsSupervised?: BorrowUncheckedCreateNestedManyWithoutFicInput
    ficApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByFicInput
    staffApprovals?: BorrowUncheckedCreateNestedManyWithoutApprovedByStaffInput
    groupBorrowMembership?: BorrowGroupMateUncheckedCreateNestedManyWithoutUserInput
    userDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutUserInput
    taggedDeficiencies?: DeficiencyUncheckedCreateNestedManyWithoutTaggedByInput
  }

  export type UserCreateOrConnectWithoutNotifiedFicDeficienciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotifiedFicDeficienciesInput, UserUncheckedCreateWithoutNotifiedFicDeficienciesInput>
  }

  export type BorrowUpsertWithoutDeficienciesInput = {
    update: XOR<BorrowUpdateWithoutDeficienciesInput, BorrowUncheckedUpdateWithoutDeficienciesInput>
    create: XOR<BorrowCreateWithoutDeficienciesInput, BorrowUncheckedCreateWithoutDeficienciesInput>
    where?: BorrowWhereInput
  }

  export type BorrowUpdateToOneWithWhereWithoutDeficienciesInput = {
    where?: BorrowWhereInput
    data: XOR<BorrowUpdateWithoutDeficienciesInput, BorrowUncheckedUpdateWithoutDeficienciesInput>
  }

  export type BorrowUpdateWithoutDeficienciesInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
  }

  export type BorrowUncheckedUpdateWithoutDeficienciesInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type UserUpsertWithoutUserDeficienciesInput = {
    update: XOR<UserUpdateWithoutUserDeficienciesInput, UserUncheckedUpdateWithoutUserDeficienciesInput>
    create: XOR<UserCreateWithoutUserDeficienciesInput, UserUncheckedCreateWithoutUserDeficienciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserDeficienciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserDeficienciesInput, UserUncheckedUpdateWithoutUserDeficienciesInput>
  }

  export type UserUpdateWithoutUserDeficienciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutUserDeficienciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUpsertWithoutTaggedDeficienciesInput = {
    update: XOR<UserUpdateWithoutTaggedDeficienciesInput, UserUncheckedUpdateWithoutTaggedDeficienciesInput>
    create: XOR<UserCreateWithoutTaggedDeficienciesInput, UserUncheckedCreateWithoutTaggedDeficienciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaggedDeficienciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaggedDeficienciesInput, UserUncheckedUpdateWithoutTaggedDeficienciesInput>
  }

  export type UserUpdateWithoutTaggedDeficienciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    notifiedFicDeficiencies?: DeficiencyUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUncheckedUpdateWithoutTaggedDeficienciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    notifiedFicDeficiencies?: DeficiencyUncheckedUpdateManyWithoutFicToNotifyNestedInput
  }

  export type UserUpsertWithoutNotifiedFicDeficienciesInput = {
    update: XOR<UserUpdateWithoutNotifiedFicDeficienciesInput, UserUncheckedUpdateWithoutNotifiedFicDeficienciesInput>
    create: XOR<UserCreateWithoutNotifiedFicDeficienciesInput, UserUncheckedCreateWithoutNotifiedFicDeficienciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotifiedFicDeficienciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotifiedFicDeficienciesInput, UserUncheckedUpdateWithoutNotifiedFicDeficienciesInput>
  }

  export type UserUpdateWithoutNotifiedFicDeficienciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUpdateManyWithoutTaggedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotifiedFicDeficienciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    studentNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classesTaught?: ClassUncheckedUpdateManyWithoutFicNestedInput
    classesEnrolled?: UserClassEnrollmentUncheckedUpdateManyWithoutUserNestedInput
    borrowsInitiated?: BorrowUncheckedUpdateManyWithoutBorrowerNestedInput
    borrowsSupervised?: BorrowUncheckedUpdateManyWithoutFicNestedInput
    ficApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByFicNestedInput
    staffApprovals?: BorrowUncheckedUpdateManyWithoutApprovedByStaffNestedInput
    groupBorrowMembership?: BorrowGroupMateUncheckedUpdateManyWithoutUserNestedInput
    userDeficiencies?: DeficiencyUncheckedUpdateManyWithoutUserNestedInput
    taggedDeficiencies?: DeficiencyUncheckedUpdateManyWithoutTaggedByNestedInput
  }

  export type ClassCreateManyFicInput = {
    id?: string
    courseCode: string
    section: string
    semester: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserClassEnrollmentCreateManyUserInput = {
    id?: string
    classId: string
    createdAt?: Date | string
  }

  export type BorrowCreateManyBorrowerInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowCreateManyFicInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowCreateManyApprovedByFicInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowCreateManyApprovedByStaffInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowGroupMateCreateManyUserInput = {
    id?: string
    borrowId: string
    createdAt?: Date | string
  }

  export type DeficiencyCreateManyUserInput = {
    id?: string
    borrowId: string
    taggedById: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyCreateManyTaggedByInput = {
    id?: string
    borrowId: string
    userId: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeficiencyCreateManyFicToNotifyInput = {
    id?: string
    borrowId: string
    userId: string
    taggedById: string
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateWithoutFicInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: UserClassEnrollmentUpdateManyWithoutClassNestedInput
    borrowRequests?: BorrowUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutFicInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: UserClassEnrollmentUncheckedUpdateManyWithoutClassNestedInput
    borrowRequests?: BorrowUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutFicInput = {
    courseCode?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type UserClassEnrollmentUncheckedUpdateWithoutUserInput = {
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentUncheckedUpdateManyWithoutUserInput = {
    classId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUpdateWithoutBorrowerInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutBorrowerInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateManyWithoutBorrowerInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUpdateWithoutFicInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutFicInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateManyWithoutFicInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUpdateWithoutApprovedByFicInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutApprovedByFicInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateManyWithoutApprovedByFicInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUpdateWithoutApprovedByStaffInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutApprovedByStaffInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateManyWithoutApprovedByStaffInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrow?: BorrowUpdateOneRequiredWithoutGroupMatesNestedInput
  }

  export type BorrowGroupMateUncheckedUpdateWithoutUserInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateUncheckedUpdateManyWithoutUserInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUpdateWithoutUserInput = {
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrow?: BorrowUpdateOneRequiredWithoutDeficienciesNestedInput
    taggedBy?: UserUpdateOneRequiredWithoutTaggedDeficienciesNestedInput
    ficToNotify?: UserUpdateOneWithoutNotifiedFicDeficienciesNestedInput
  }

  export type DeficiencyUncheckedUpdateWithoutUserInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUncheckedUpdateManyWithoutUserInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUpdateWithoutTaggedByInput = {
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrow?: BorrowUpdateOneRequiredWithoutDeficienciesNestedInput
    user?: UserUpdateOneRequiredWithoutUserDeficienciesNestedInput
    ficToNotify?: UserUpdateOneWithoutNotifiedFicDeficienciesNestedInput
  }

  export type DeficiencyUncheckedUpdateWithoutTaggedByInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUncheckedUpdateManyWithoutTaggedByInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUpdateWithoutFicToNotifyInput = {
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrow?: BorrowUpdateOneRequiredWithoutDeficienciesNestedInput
    user?: UserUpdateOneRequiredWithoutUserDeficienciesNestedInput
    taggedBy?: UserUpdateOneRequiredWithoutTaggedDeficienciesNestedInput
  }

  export type DeficiencyUncheckedUpdateWithoutFicToNotifyInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUncheckedUpdateManyWithoutFicToNotifyInput = {
    borrowId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowCreateManyEquipmentInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    classId: string
    ficId?: string | null
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowUpdateWithoutEquipmentInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    class?: ClassUpdateOneRequiredWithoutBorrowRequestsNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutEquipmentInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateManyWithoutEquipmentInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentCreateManyClassInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BorrowCreateManyClassInput = {
    id?: string
    requestSubmissionTime?: Date | string
    requestedStartDate: Date | string
    borrowerId: string
    ficId?: string | null
    equipmentId: string
    borrowStatus?: $Enums.BorrowStatus
    approvedByFicId?: string | null
    approvedByStaffId?: string | null
    checkoutTime?: Date | string | null
    expectedReturnTime?: Date | string | null
    actualReturnTime?: Date | string | null
    returnCondition?: string | null
    returnRemarks?: string | null
    editHistory?: BorrowCreateeditHistoryInput | InputJsonValue[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserClassEnrollmentUpdateWithoutClassInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClassesEnrolledNestedInput
  }

  export type UserClassEnrollmentUncheckedUpdateWithoutClassInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserClassEnrollmentUncheckedUpdateManyWithoutClassInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowUpdateWithoutClassInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    borrower?: UserUpdateOneRequiredWithoutBorrowsInitiatedNestedInput
    fic?: UserUpdateOneWithoutBorrowsSupervisedNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutBorrowRecordsNestedInput
    groupMates?: BorrowGroupMateUpdateManyWithoutBorrowNestedInput
    approvedByFic?: UserUpdateOneWithoutFicApprovalsNestedInput
    approvedByStaff?: UserUpdateOneWithoutStaffApprovalsNestedInput
    deficiencies?: DeficiencyUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateWithoutClassInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    groupMates?: BorrowGroupMateUncheckedUpdateManyWithoutBorrowNestedInput
    deficiencies?: DeficiencyUncheckedUpdateManyWithoutBorrowNestedInput
  }

  export type BorrowUncheckedUpdateManyWithoutClassInput = {
    requestSubmissionTime?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    borrowerId?: StringFieldUpdateOperationsInput | string
    ficId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    borrowStatus?: EnumBorrowStatusFieldUpdateOperationsInput | $Enums.BorrowStatus
    approvedByFicId?: NullableStringFieldUpdateOperationsInput | string | null
    approvedByStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    returnCondition?: NullableStringFieldUpdateOperationsInput | string | null
    returnRemarks?: NullableStringFieldUpdateOperationsInput | string | null
    editHistory?: BorrowUpdateeditHistoryInput | InputJsonValue[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateCreateManyBorrowInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type DeficiencyCreateManyBorrowInput = {
    id?: string
    userId: string
    taggedById: string
    ficToNotifyId?: string | null
    type: $Enums.DeficiencyType
    status?: $Enums.DeficiencyStatus
    description?: string | null
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BorrowGroupMateUpdateWithoutBorrowInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGroupBorrowMembershipNestedInput
  }

  export type BorrowGroupMateUncheckedUpdateWithoutBorrowInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BorrowGroupMateUncheckedUpdateManyWithoutBorrowInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUpdateWithoutBorrowInput = {
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserDeficienciesNestedInput
    taggedBy?: UserUpdateOneRequiredWithoutTaggedDeficienciesNestedInput
    ficToNotify?: UserUpdateOneWithoutNotifiedFicDeficienciesNestedInput
  }

  export type DeficiencyUncheckedUpdateWithoutBorrowInput = {
    userId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeficiencyUncheckedUpdateManyWithoutBorrowInput = {
    userId?: StringFieldUpdateOperationsInput | string
    taggedById?: StringFieldUpdateOperationsInput | string
    ficToNotifyId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDeficiencyTypeFieldUpdateOperationsInput | $Enums.DeficiencyType
    status?: EnumDeficiencyStatusFieldUpdateOperationsInput | $Enums.DeficiencyStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}